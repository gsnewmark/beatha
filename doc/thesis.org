* Моделювання процесів за допомогою модифікованих клітинних автоматів
** Вступ
** Модифікація клітинних автоматів
*** Огляд клітинних автоматів
Вперше клітинні автомати були запропоновані у 1940-50-х роках в роботах фон
Неймана та Улама[1]. Проте наступні 30 років такий тип автоматів не дуже
цікавив дослідників. У 1970-х Конвей запропонував так звану Гру Життя (Game of
Life) - двовимірний клітинний автомат, що описувався простим набором правил,
проте генерував напрочуд цікаво поведінку. В 1980-х глибоким дослідженням
одновимірних клітинних автоматів займався Стівен Вольфрам, зокрема він
запропонував їх класифікацію.

Клітинні автомати - особливий клас дискретних динамічних систем, дискретними в
яких є час, простір та множина станів. Зазвичай клітинний автомат
представляється як об'єднання однакових комірок (клітин), з'єднаних між
собою. Разом клітини утворюють так звану клітинну решітку (форма якої може
бути різноманітною). Клітина виступає скінченним автоматом, стан якого на
кроці /t+1/ визначається станом системи (а саме сусідів та самої клітини) на
попередньому кроці /t/ та набором локальних правил взаємодії сусідніх
клітин. Рідше під час визначення стану використовуються глобальні правила -
такі, що визначають вплив певної загальної змінної на всі клітини автомату.[2]
Саме розширення такими глобальними правилами буде досліджено у даній роботі.

На кожному кроці кожна клітина приймає один із станів з наявної скінченної
множини станів /S/, котре може розглядатись як /k/-вимірний алфавіт /S/ = {0,
1, ..., k-1}.

Якщо кожна клітина має /2r/ сусідів, локальне правило переходу виглядає
наступним чином /ϕ : S^{2r+1} → S/. Правило може бути детермінованим або
стохастичним.

Для визначення сусідів конкретної клітини у двовимірному автоматі існує
декілька підходів, найпопулярніші з яких "сусідство" фон Неймана та
"сусідство" Мура[3]. Перший розглядає лише чотири клітини, котрі безпосередньо
торкаються поточної клітини (згори, знизу, зліва та справа). А другий підхід
додає до цих чотирьох ще чотири клітини, що знаходяться на діагоналях відносно
поточної клітини. Надалі буде розглядатись підхід Мура, тому правило переходу
можна записати наступним чином /a_{i,j}^{(t+1)} = ϕ(a_{i,j}^{(t)},
a_{i,j+1}^{(t)}, a_{i+1,j}^{(t)}, a_{i+1,j+1}^{(t)}, a_{i,j-1}^{(t)},
a_{i-1,j}^{(t)}, a_{i-1,j-1}^{(t)}, a_{i-1,j+1}^{(t)},
a_{i+1,j-11}^{(t)})/.

Так як автомат представляє собою обмежену сітку, постає проблема визначення
сусідів клітин, котрі знаходяться на межах цієї сітки. Одним з
найпопулярніших шляхів розв'язання проблеми є використання тороїдальної
структури сітки - якщо клітина немає сусіда згори, цим сусідом виступає
клітина на відповідній позиції знизу сітки, аналогічно відбувається "перехід"
для інших клітин на межах.

Ітеративний процес роботи автомату полягає у тому, що на кожному кроці
наведена вище функція застосовується до кожної клітини водночас. Тобто, кожна
клітина оброблюється паралельно та незалежно, що робить клітинні автомати
гарним інструментом моделювання процесів зі схожою паралельною структурою,
наприклад, економічної взаємодії.

Зазвичай клітинні автомати у пам'яті комп'ютера представляються як масиви
комірок, де кожна комірка відповідає певній клітині автомата. Водночас
більшість автоматів описується в термінах певної підмножини "живих" станів та
визначення сусідів клітин ("мертві" клітини можуть бути вираховані
користуючись цією інформацією). Тому такий автомат можливо представити просто
як множину "живих" клітин.[4] Саме такий варіант представлення (дещо
модифікований для конкретних задач) використовувався у роботі.
*** Розширення керуючим інформаційним каналом
*** Розширення вихідним інформаційним каналом
*** Використання модифікованого автомату для розпізнавання необмеженої граматики
** Модель економічних відносин
*** Опис моделі
*** Загальна структура клітинного автомату
*** Використання керуючого та вихідного каналів
** Візуалізація клітинних автоматів
*** React та ідея virtual DOM
*** ClojureScript та Om
Застосування було виконано у формі так званого single-page application, при
чому серверна частина у нього відсутня, всі обрахунки відбуваються на
клієнтській стороні.

Для реалізації використовувалась мова програмування ClojureScript. Вона є
варіантом мови Clojure, котрий запускається не на JVM, а компілюється у
JavaScript. Хоча й ClojureScript не має всіх можливостей мови Clojure
(зокрема, багатопоточності), але підтримує базову семантику даної мови,
зокрема незмінні структури даних, "ліниві" послідовності, функції вищого
порядку, простори імен та навіть макроси. Основна відмінність між Clojure та
ClojureScript - якщо перша мова працює спільно з Java та має можливості
інтероперабельності з саме цією мовою, то друге вже використовує JavaScript у
ролі "батьківського" середовища та інтероперує з ним.

ClojureScript генерує немініфікований та необфускований JavaScript код, котрий
надалі передається на вхід Google Closure Compiler[5], котрий і оптимізує
отриманий код. Разом з компілятором до складу Google Closure входить набір
низькорівневих бібліотек для більшості буденних задач, що виникають під час
розробки JavaScript застосувань - наприклад, надсилання запитів до
сервера. ClojureScript надає до них повний доступ без необхідності їх
додаткового завантаження та додавання на сторінку.

Цікавою особливістю є те, що і компілятор ClojureScript, і компілятор Google
Closure запускається на JVM - перший компілятор написаний на Clojure, а другий
на Java. Загалом процес перетворення ClojureScript у готовий до використання
JavaScript код відбувається наступним чином[6]:

[[./cljs_compilation.png]]

Генерація HTML-відображення у застосуванні здійснюється за допомогою
бібліотеки Om[7]. Вона є обгорткою над розглянутою раніше JS-бібліотекою
React, а також додає власну модель збереження стану застосування.

Om, як і React, пропонує використовувати незалежні, але зв'язані один з одним,
компоненти, проте на відміну від React, всі дані, що передаються між
компонентами є незмінними. Всі дані, необхідні для генерації відображення,
зберігаються у одному кореневому контейнері, котрий змінюється за допомогою
механізму транзакцій. Зазвичай контейнером виступає звичайний асоціативний
масив, що має деревоподібну структуру (тобто, має багато вкладених
асоціативних масивів), кожна "гілка" цього масиву використовується одним з
(або декількома) компонентами, що входять до складу застосування.

Всередину компоненту передається не сам контейнер з даними, а так званий
курсор, що описує певний шлях всередину контейнеру (на концептуальному рівні
курсор схожий на таке поняття зі сфери структур даних як zipper). Фактично,
курсор обмежує область видимості даних для компонента лише необхідними йому
даними, водночас зберігає можливість оновлювати ці дані з компоненту, не
знаючи про загальну структуру контейнера з даними.

Для кожного з етапів життєвого циклу компоненту React передбачений бібліотекою
передбачений свій протокол - для того, щоб визначити особливу поведінку під
час конкретного етапу, достатньо реалізувати відповідний протокол. Кожний
Om-компонент має визначити щонайменше протокол, котрий описує render-фазу
(безпосередню генерацію HTML, протокол IRender або IRenderState). Під час
створення екземпляру компонента йому обов'язково передається курсор на певну
частину загального контейнера з даними. Дані з курсору доступні напряму під
час фази render, проте під час інших фаз до них можна звертатись лише як до
атому (один з базових елементів Clojure/ClojureScript) - попередньо потрібно
"розіменувати" (dereference) посилання, котрим, по суті,  курсор.
*** Communicating Sequential Processes та core.async
*** Огляд виконаної реалізації
** Висновки
** Список літератури
1. Клеточные автоматы. Реализация и эксперименты - Лев Наумов, Анатолий Шалыто
2. Modelling the Spatial Dimension of Economic Systems with Cellular
   Automata - Max Keilbach
3. https://en.wikipedia.org/wiki/Cellular_automaton
4. Clojure Programming - Chas Emerick, Brian Carper, Christophe Gran
5. https://developers.google.com/closure/
6. ClojureScript Up and Running - Stuart Sierra, Luke VanderHart
7. https://github.com/swannodette/om
