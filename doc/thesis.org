#+TITLE: Моделювання процесів за допомогою модифікованих клітинних автоматів
#+LANGUAGE: uk
#+AUTHOR: Іван Криворучко

* Вступ
Від часів опублікування першого опису Гри Життя клітинні автомати набули
широкого поширення серед різних поколінь математиків та програмістів. Простий
за своєю суттю апарат дозволяє робити навіть малокваліфікованому спеціалісту
цікаві експерименти, котрі переважно заключаються у генерації різноманітних
візерунків та автономних віртуальних світів. Водночас, більш серйозні
застосування клітинних автоматів хоч й існують, проте маловідомі широкому
загалу.

Дещо зупинились і більш теоретичні дослідження клітинних автоматів: багато
часу для їх аналізу витрачали науковці 1970-80х років, а зараз серйозні роботи
присвячені даній моделі зустрічаються доволі рідко. Разом з тим, не зважаючи
на всю зовнішню простоту моделі досі залишаються можливості її подальшого
удосконалення, котрі можуть зробити клітинні автомати ще більш "виразною"
мовою опису динамічних систем та процесів. Зокрема, цікавою виглядає
можливість поєднання клітинних каналів з каналами даних, що дозволяють певним
чином збирати та розсилати інформацію з усіх клітин автомату, таким чином
доповнюючи локальну взаємодію клітин автомату можливістю глобальної взаємодії.

Можна припустити, що таке розширення моделі дозволить ще більш точно
моделювати різноманітні процеси реального життя, особливо ті, які подібним
чином поєднують локальні та глобальні зміни у своєму стані. Зокрема, такі
клітинні автомати можуть виявитись гарною апроксимацією ринку, моделючи як
товарний обмін між різними його учасниками так і участь держави у формі збору
податків та загального контролю ринку (якщо він присутній). Остання задача
стає напрочуд актуальною у світлі останніх процесів, що відбуваються у нашому
суспільстві - здатність відносно простим чином моделювати різні варіанти
податкового законодавства може стати у нагоді під час можливих майбутніх
реформ даної сфери.
* Постановка задачі
В рамках даної роботи буде досліджено можливість розширення стандартних
клітинних автоматів двома додатковими каналами даних. Один з них на кожному
кроці певним чином агрегує інформацію про поточний стан автомату на надає її
користувачу, а другий -  розповсюджує певну команду на всі клітини, кожна така
команда змінює функцію переходу клітини в обхід звичних правил клітинного
автомату. Модифікований таким чином автомат буде використаний для моделювання
економічної взаємодії робітників, підприємств та держави. Також, буде створена
система візуалізації клітинних автоматів з підтримкою описаних вище
модифікацій.
* Модифікація клітинних автоматів
** Огляд клітинних автоматів
Вперше клітинні автомати були запропоновані у 1940-50-х роках в роботах фон
Неймана та Улама[1]. Проте наступні 30 років такий тип автоматів не дуже
цікавив дослідників. У 1970-х Конвей запропонував так звану Гру Життя (Game of
Life) - двовимірний клітинний автомат, що описувався простим набором правил,
проте генерував напрочуд цікаво поведінку. В 1980-х глибоким дослідженням
одновимірних клітинних автоматів займався Стівен Вольфрам, зокрема він
запропонував їх класифікацію.

Клітинні автомати - особливий клас дискретних динамічних систем, дискретними в
яких є час, простір та множина станів. Зазвичай клітинний автомат
представляється як об'єднання однакових комірок (клітин), з'єднаних між
собою. Разом клітини утворюють так звану клітинну решітку (форма якої може
бути різноманітною). Клітина виступає скінченним автоматом, стан якого на
кроці /t+1/ визначається станом системи (а саме сусідів та самої клітини) на
попередньому кроці /t/ та набором локальних правил взаємодії сусідніх
клітин. Рідше під час визначення стану використовуються глобальні правила -
такі, що визначають вплив певної загальної змінної на всі клітини автомату.[2]
Саме розширення такими глобальними правилами буде досліджено у даній роботі.

На кожному кроці кожна клітина приймає один із станів з наявної скінченної
множини станів /S/, котре може розглядатись як /k/-вимірний алфавіт /S/ = {0,
1, ..., k-1}.

Якщо кожна клітина має /2r/ сусідів, локальне правило переходу виглядає
наступним чином /ϕ : S^{2r+1} → S/. Правило може бути детермінованим або
стохастичним.

Для визначення сусідів конкретної клітини у двовимірному автоматі існує
декілька підходів, найпопулярніші з яких "сусідство" фон Неймана та
"сусідство" Мура[3]. Перший розглядає лише чотири клітини, котрі безпосередньо
торкаються поточної клітини (згори, знизу, зліва та справа). А другий підхід
додає до цих чотирьох ще чотири клітини, що знаходяться на діагоналях відносно
поточної клітини. Надалі буде розглядатись підхід Мура, тому правило переходу
можна записати наступним чином /a_{i,j}^{(t+1)} = ϕ(a_{i,j}^{(t)},
a_{i,j+1}^{(t)}, a_{i+1,j}^{(t)}, a_{i+1,j+1}^{(t)}, a_{i,j-1}^{(t)},
a_{i-1,j}^{(t)}, a_{i-1,j-1}^{(t)}, a_{i-1,j+1}^{(t)},
a_{i+1,j-11}^{(t)})/.

Так як автомат представляє собою обмежену сітку, постає проблема визначення
сусідів клітин, котрі знаходяться на межах цієї сітки. Одним з
найпопулярніших шляхів розв'язання проблеми є використання тороїдальної
структури сітки - якщо клітина немає сусіда згори, цим сусідом виступає
клітина на відповідній позиції знизу сітки, аналогічно відбувається "перехід"
для інших клітин на межах.

Ітеративний процес роботи автомату полягає у тому, що на кожному кроці
наведена вище функція застосовується до кожної клітини водночас. Тобто, кожна
клітина оброблюється паралельно та незалежно, що робить клітинні автомати
гарним інструментом моделювання процесів зі схожою паралельною структурою,
наприклад, економічної взаємодії.

Зазвичай клітинні автомати у пам'яті комп'ютера представляються як масиви
комірок, де кожна комірка відповідає певній клітині автомату. Водночас
більшість автоматів описується в термінах певної підмножини "живих" станів та
визначення сусідів клітин ("мертві" клітини можуть бути вираховані
користуючись цією інформацією). Тому такий автомат можливо представити просто
як множину "живих" клітин.[4] Саме такий варіант представлення (дещо
модифікований для конкретних задач) використовувався у роботі.
** Розширення вихідним інформаційним каналом
Першою розглянутою модифікацією є додавання до звичайного клітинного автомату
так званого вихідного інформаційного каналу. Такий канал на кожній ітерації
роботи автомату збирає інформацію про поточний його стан, певним чином агрегує
її відсилає створене повідомлення "у зовнішній світ".

Агрегуюча функція обирається відповідно до задачі, що моделюється
автоматом. Прикладом може бути кількість клітин у певному стані, стан, котрий
має найбільшу кількість представників, різноманітні предикати (зокрема,
перевірка чи кількість клітин певного стану перевищує задану), тощо.

Надсилання повідомлення може здійснюватись багатьма різними способами, в даній
роботі був обраний підхід Communicating Sequential Processes, так як
запропоновані в ньому абстракції доволі вдало вписуються в описаний
механізм. Більш детальний огляд CSP наведений у відповідному розділі, на
даному етапі достатньо зазначити, що CSP передбачає створення так званих
каналів (channels), у які незалежні процеси здатні направляти повідомлення для
спілкування один з одним. По суті, канали у CSP виступають більш
формалізованими чергами.

Сама по собі модифікація не додає нічого нового безпосередньо до виразної
потужності самого автомату, проте його наявність, по-перше, спрощує деякі
моменти роботи з клітинним автоматом, насамперед з визначенням необхідності
зупинки автомату, по-друге, може виступати своєрідним індикатором, котрий
визначає бажану поведінку наступної запропонованої модифікації - керуючого
інформаційного каналу.
** Розширення керуючим інформаційним каналом
Друга модифікація - додавання керуючого інформаційного каналу - змінює модель
клітинних автоматів, більш суттєво. Доданий канал на кожному кроці може
прийняти повідомлення із зовнішнього світу (для передачі цих повідомлень у
створеній реалізації також використовується CSP), котре містить команду -
формальним чином сформована сутність, котра змінює функцію переходу автомату
для всіх подальших ітерацій.

Фактично, отримуємо наступну функцію переходу (використовується "сусідство"
Мура): /a_{i,j}^{(t+1)} = ϕ(a_{i,j}^{(t)},
a_{i,j+1}^{(t)}, a_{i+1,j}^{(t)}, a_{i+1,j+1}^{(t)}, a_{i,j-1}^{(t)},
a_{i-1,j}^{(t)}, a_{i-1,j-1}^{(t)}, a_{i-1,j+1}^{(t)},
a_{i+1,j-11}^{(t)}) if c?() == false OR c(a_{i,j}^{(t)},
a_{i,j+1}^{(t)}, a_{i+1,j}^{(t)}, a_{i+1,j+1}^{(t)}, a_{i,j-1}^{(t)},
a_{i-1,j}^{(t)}, a_{i-1,j-1}^{(t)}, a_{i-1,j+1}^{(t)},
a_{i+1,j-11}^{(t)}) if c?() == true/, де /c(...)/ - отримана команда, а
/c?()/ - предикат, що визначає чи команда наразі активована. Як і агрегуюча
функція вихідного каналу, команда, що буде надсилатись, буде відрізнятись для
конкретних автоматів, більше того, для одного автомату може використовуватись
декілька різних типів команд, вибір між застосуванням яких робиться зовнішнім
світом (користувачем) і може засновуватись на показниках, котрі повертає
вихідний інформаційний канал.

Потенційно, дана модифікація дозволяє деяким чином усунути детермінованість
автомату (котра частково зберігається навіть при використанні стохастичних
правил переходу) та надає користувачу змогу впливати на працюючий автомат. Для
задач моделювання ця модифікація цікава насамперед тим, що дає змогу відносно
простим шляхом симулювати зовнішній вплив на процес або систему: наприклад,
державне регулювання економічної взаємодії корпорацій та робітників.

Розглянемо застосування даних модифікацій на прикладі конкретної задачі.
** Використання модифікованого автомату для розпізнавання необмеженої граматики
Розглянемо задачу створення розпізнавача мови, що описується необмеженою
граматикою.

Нагадаємо, що необмежена граматика (тип-0) - найбільш загальний клас граматик
у ієрархії Чомського, у якій на ліву та праву частини правил не накладаються
ніякі обмеження. Мови, описані такими граматиками, є рекурсивно-злічениим та
розпізнаються машиною Тюринга.[12] Представником даної граматики є наступна
мова =L = { ww : w є А* }, A = {a, b}=, котра, по суті, описує мову усіх слів
з парною кількістю літер, в яких перша половина слова ідентична другій
половині, при чому літер належать алфавіту з двох символів. Для саме цієї мови
і було створено клітинний автомат-розпізнавач.

В ньому використовується три основних стани - =dead=, =a= та =b=, перший з
яких означає порожню клітини, а наступі два відповідають літерам
алфавіту. Таким чином слово представляється послідовним горизонтальним
ланцюжком клітин стану =a= та =b=:

[[./screenshots/parser_word.png]]

Стан/літера =а= показана зеленим кольором, а =b= - бузковим, сірий колір -
"мертві" клітини. Для розпізнавання слова вводиться набір проміжних станів, та
відбувається певні перетворення в результаті яких на сітці автомату
з'являється клітина у стані, що кодує успішне (=s=) або провальне (=f=)
розпізнання слова. Кількість клітин у цих станах на кожному кроці передається
у вихідний інформаційний канал, і коли кількість одного з цих станів перевищує
нуль робота автомату зупиняється з успіхом або провалом (відповідне
повідомлення показується у графічному інтерфейсі).

Правила переходу автомату виглядають наступним чином:

#+BEGIN_SRC clojure
(cond
 (and (dead? s) (alive-only :right letter?))    :lc
 (and (dead? s) (alive-only :left letter?))     :rc
 (and (dead? s)
      (or (alive-only :right #{:lc})
          (alive-only :left #{:rc})))           :x
 (and (= :lc s)
      (between-l-r #{:x :a :b :dead} letter?))  right
 (and (= :rc s)
      (between-l-r letter? #{:x :a :b :dead}))  left
 (and (letter? s) (between-l-r #{:lc} letter?)) :lc
 (and (letter? s) (between-l-r letter? #{:rc})) :rc
 (between-l-r #{:lc} #{:rc})                    :f
 (or (and (= :lc s) (= :rc right))
     (and (= :lc left) (= :rc s)))              :m
 (and (dead? s) (= :m top))                     :n
 (and (dead? s) (letter? top) (= :n right))     :n
 (and (dead? s) (letter? top)
      (#{:n :a :b} left))                       top
 (and (= :n s) (letter? right))                 right
 (and (letter? s) (= :n left))                  :n
 (and (letter? s) (= :x left) (= s bottom))     :x
 (and (letter? s) (= :x left)
      (letter? bottom) (not (= s bottom)))      :f
 (and (= :m s) (= :x left))                     :s
 :else                                          s)
#+END_SRC

де =s= - поточний стан клітини, =dead?= - предикат, що визначає чи є клітина
"мертвою", =alive-only= визначає, що живим є лише один сусід на певній позиції
і він має певний стан, =between-l-r= перевіряє, що клітина знаходиться між
двома клітинами у певних заданих станах, =left=, =right=, =top=, =bottom= -
стани сусідів зліва, справа, згори, знизу, а всі символи, що починаються з
=:= - позначки відповідних станів клітин.

Розглянемо основні моменти роботи автомату більш детально. Перш за все
автоматом слово розбивається на дві рівні частини, якщо ж це виконати
неможливо (кількість літер у слові непарна) з'являється клітина у стані
=f=. Для цього по одній мертвій клітині з боків слова утворюється стани =lc=
та =rc= котрі з кожним кроком міняються місцями з клітиною справа та зліва
відповідно. Коли вони стають сусідами одна одної, вони перетворюються у
середину слова (стан =m=), а межі виділяються станом =x=:

[[./screenshots/parser_middle.png]]

межі та середини слова виділені чорним кольором. Якщо автомат приходить до
ситуації, коли у певної клітини лівий та правий сусіди у станах =lc= та =rc=
відповідно, це значить, що кількість літер у слові непарна і дана клітина
переходить у стан =f=.

Далі, для порівняння частин слова на рівність використовується наступна
процедура: клітини автомату, що знаходяться безпосередньо під "літерами" слова
та його серединою переходить у стан =n=, а надалі літери правої частини слова
переміщаються на відповідні позиції новоствореного нижнього ряду та починає
рухатись вліво шляхом обміну станами з клітинами зліва, що перебувають у стані
=n=. Рух зупиняється якщо зліва "мертва" клітина, або клітина-літера:

[[./screenshots/parser_lower_row.png]]

клітини у стані =n= зображені темно-зеленим кольором. Якщо рух клітини у
нижньому ряді зупинився і при цьому вона перебуває у такому ж стані, як
клітина над нею - верхня клітина переходить у стан =x=, якщо ж стани не
співпадають - верхня клітина переходить у стан =f= (розпізнання слова
провалилось). Коли всі клітини лівої частини слова переходять у стан =x=
(тобто всі клітини нижнього ряду перебували у такому ж стані, як відповідні
ним клітини лівої половини слова), це значить, що слово розпізнано успішно, і
одна з клітин середини слова переходить у стан успіху =s=:

[[./screenshots/parser_success.png]]

"успішна" клітина виділена блакитним кольором.

За допомогою керуючого каналу автомату можливо вказати, що певна літера має
поводитись як "підстановка" (wildcard) - тобто, при перевірці на рівність дана
літера буде рівна не лише собі, а й іншій літері. Наприклад, початкове слово,
котре не мало б розпізнатись:

[[./screenshots/parser_invalid.png]]

Але якщо надіслати команду, що і =a=, і =b= розпізнаються як "підстановки",
слово буде розпізнано автоматом успішно:

[[./screenshots/result_invalid_success.png]]

Таким чином, ми впевнелись, що клітинний автомат здатний розпізнавати такий
клас мав, котрий відповідає машинам Тюринга, водночас, за допомогою
запропонованих каналів даних вдалось дещо спростити використання автомату
(визначення моменту зупинки), а також розширити його можливості додатковими
опціональними правилами поведінки за допомогою керуючого каналу. Розглянемо
використання каналів у більш складній моделі.
* Модель економічних відносин
** Опис моделі
Для перевірки дієздатності запропонованої модифікації клітинного автомату було
вирішено промоделювати економічну взаємодію покупців та клієнтів виробників на
ринку інформаційних послуг/сервісів: він характеризується схильністю покупців
до вибору товару, котрий вже є у його оточення, що ідеально вписується у
загальну схему роботи клітинного автомату, а також характеризується більш-менш
стійкою прив'язкою клієнта до обраного товару.

За основу була взята модель описана у статті "Modelling the Spatial Dimension
of Economic Systems with Cellular Automata"[2]. Сітка автомату обмежена -
містить /N/ клітин, кожна з яких представляє одного покупця, а сусіди
(використовується "сусідство" Мура, тобто кожна клітина має вісім сусідів),
відповідно, є оточенням конкретного покупця. На ринку змагаються /M/ компаній,
котрі не представлені безпосередньо на сітці автомату, натомість кожна
клітина-покупець на певній ітерації володіє товаром одної з цих компаній -
відповідно стан клітини показує, який товар вона обрала. Тобто, алфавіт станів
/S/ можна описати наступним чином /S = {0, 1, ..., M}/, де 0 відповідає
відсутності товару, а товару 1, ..., /M/ компаніям з відповідним порядковим
номером.

Всі покупці є однаковими у тому розумінні, що мають однакову функцію
корисності. Вона включає в себе три основні компоненти:

- кількість сусідів з певним товаром
- загальний відсоток ринку, "зайнятий" цим товаром
- вартість товару

При цьому куплений товар має так званий строк придатності - на кожному кроці
роботи автомату куплений товар може "зламатись" з базовою ймовірністю /d/, тим
самим перевівши автомат у стан "без товару". Для конкретної компанії базова
ймовірність зламатись може як збільшитись, так і зменшитись в залежності від
поточної середньої ціни. Реальна ймовірність "зламатись" /rd/ обчислюється
наступним чином:

/rd(k) = d * p(k)/(E_{l=1}^{M}p(l)/M)/

де /k/ - номер компанії, /p(i)/ - ціна товару i-тої компанії.

Обирають та купують товари лише ті клітини, котрі під час даної ітерації не
мають ніякого товару, тобто покупці, що вже мають певний товар, не змінюють
його, допоки він не "зламається".

Формально функцію корисності покупця з координатами /(i,j)/ для товару від
компанії /k/ можна описати наступним чином:

/U_{i,j}(k) = (b_{i,j}(k)/nn)^{a} * s(k) * pr(k)^{p}/

де /b_{i,j}(k)/ - кількість сусідів поточної клітини, що володіють товаром
від компанії /k/, /nn/ - загальна кількість сусідів (фактично, є константою,
що дорівнює восьми, бо використовується торусо-подібна сітка), /s_{k}/ -
частина ринку, що належить компанії /k/, /pr(k)/ - ціна товару компанії /k/,
/a/ та /p/ - параметри алгоритму, що відповідають за локальне "поширення"
товару та його вартість відповідно.

З даної функції корисності можна отримати і відношення переваг між різними
виробниками для конкретного покупця, яке водночас визначає з якою ймовірністю
покупець обере товар певної компанії:

/RP_{i,j}^{k} = U_{i,j}(k)/E_{l=1}^{M}U_{i,j}(l)/

Компанії отримують гроші не лише за продаж товару, але й за його використання:
тобто, на кожній ітерації компанія отримує /pr(k)*n(k)/ одиниць прибутку, де
/n(k)/ - поточна кількість клітин у стані /k/ (покупців, що користуються
товаром даної компанії). При цьому на кожного покупця компанії витрачає
фіксовану суму /eс/ (двадцять одиниць) для підтримання надання товару.

Присутня у моделі і держава. На кожній ітерації компанії додаткову сплачують
певний податок державі, а сама держава витрачає фіксовану суму /eg/ (одна
одиниця) на підтримку існування кожної клітини автомату. Період роботи
автомату розбивається на роки: параметр /T/ вказує тривалість року у ітераціях
(за замовченням один рік триває дванадцять ітерацій).

Якщо на певній ітерації капітал компанії стає менше нуля, вона оголошується
банкрутом, втрачає всіх своїх покупців (вони переходять у стан "без товар") та
надалі більше не продає товар.

Функція переходу станів клітини є доволі простою:

#+BEGIN_SRC clojure
{:state
  (cond
    (or (< (rand) (* (:depreciation env)
                     (/ current-price avg-price)))
        (bankrupt? s))
    :without-good

   (without-good? s)
   (if-let [c (weighted
               (user-preferences env global-share n-states))]
     c
     :without-good)

   :else s)}
#+END_SRC

де =(:depreciation env)= - значення параметра =d=, =(bankrupt? s)= визначає чи
є банкрутом компанія-постачальник поточного купленого товару,
=(user-preferences env global-share n-states)= знаходить ймовірності обрати
товар певної компанії даною клітиною, а =weighted= робить зважений вибір
відповідно до знайдених ймовірностей, =:without-good= позначає стан "без
товару".

Модель підтримує три основні схеми оподаткування: відсоток з чистого доходу,
відсоток з обороту та фіксована сума. Кожній із схем відповідає свій
параметер, котрий можна налаштовувати за допомогою керуючого каналу. Під
оборотом розуміється сума надходжень від покупців без віднімання витрат на
їх підтримання, а під чистим доходом - з відніманням цих витрат. Перейдемо
до більш докладного огляду використання інформаційних каналів.
** Використання керуючого та вихідного каналів
Як згадувалось раніше керуючий канал можна використовувати для зміни
параметрів алгоритму, зокрема /a/, /p/, /d/, розміри відсотку/суми податків. А
у вихідний канал на кожній ітерації автомат направляє інформацію про поточний
стан моделі, а саме поточні значення всіх параметрів, що налаштовуються
керуючим каналом, розмір витрат на утримання комірки компаніями та державою,
загальна кількість компаній, вартості товарів, капітал держави та компанії,
сумарний прибуток та чистий прибуток, отримані компаніями за поточний рік,
сумарні витрати на підтримання існування користувачів за поточний рік,
розподіл ринку між компаніями та поточна схема оподаткування, обрана кожною з
компаній. Найцікавішим є останній показник.

На початку роботи моделі кожна компанія платить як податок відсоток з обороту,
проте кожного "року" (за замовченням дванадцять ітерацій) обробник інформації
з вихідного каналу надсилає у керуючий канал команду, яка для кожної компанії,
можливо, змінює її обрану схему оподаткування. Для визначення яку саме схему
обрати на наступний рік використовується доволі наївна функція:

#+BEGIN_SRC clojure
(defn conservative-corp-tax
  [tax-rate income-tax-rate fixed-tax
   capital-incomings capital-expenditures]
  (let [tax (* tax-rate capital-incomings)
        income-tax (* income-tax-rate
                      (- capital-incomings capital-expenditures))]
    {:type :change-taxation-type
     :cmd
     (->> [[:rate tax] [:income-rate income-tax] [:fixed fixed-tax]]
          (sort-by second)
          first
          first)}))
#+END_SRC

На вхід вона приймає поточні розміри відсотку з прибутку, обороту та суми
фіксованого податку, а також сумарний прибуток та витрати за минулий рік. Для
кожного типу оподаткування підраховується сума податку, яку б треба було
заплатити за минулий рік, і з поміж отриманих значень обирається найменше, яку
і стає обраною схемою на наступний рік. У даній функції можна відмітити і
загальну структуру команди даного автомату: вона є асоціативним масивом з
двома ключами - =type= (дія, яку треба виконати) та =cmd= (інформаційне поле
специфічне для кожного типу команд). Для команди зміни схеми оподаткування
значенням інформаційного поля виступає позначка обраного типу оподаткування.

Окрім зміни схеми оподаткування кожні півроку обробник вихідного каналу для
кожної компанії надсилає команду зміни вартості товару. Функція, що визначає
ціну на наступне півріччя також є доволі простою:

#+BEGIN_SRC clojure
(defn conservative-corp-price
  [[competitor-count share capital capital-diff price]]
  (cond
   (< capital-diff 0)                        {:type :change-price
                                              :cmd (* price 1.5)}
   (and (< share (/ 1.0 competitor-count))
        (> price 100))                       {:type :change-price
                                              :cmd (/ price 3)}
   (and (< share (/ 1.0 competitor-count))
        (> price 10))                        {:type :change-price
                                              :cmd (/ price 1.5)}
   (and (< share (/ 1.0 competitor-count 2))
        (> price 100))                       {:type :change-price
                                              :cmd (/ price 4)}
   (and (< share (/ 1.0 competitor-count 2))
        (> price 10))                        {:type :change-price
                                              :cmd (/ price 2)}
   (>= share 0.33)                           {:type :change-price
                                              :cmd (* price 1.2)}
   (>= share 0.5)                            {:type :change-price
                                              :cmd (* price 1.5)}
   :else                                     {:type :change-price
                                              :cmd price}))
#+END_SRC

Функція приймає на вхід кількість конкурентів, відсоток ринку, що "належить"
компанії, розмір капіталу компанії, чистий прибуток отриманий нею за попередні
півроку та поточну ціну. Якщо за попередній період компанія зазнала збитків
або вона завоювала більше половини всього ринку, то ціна збільшується у
півтора рази, якщо завойовано третину ринку - ціна збільшується у 1.2
рази. Зменшується ціна у декількох різних ситуаціях, коли частка ринку
поточної компанії стає меншою, ніж її розмір за рівномірного розподілу між
усіма конкурентами.

Дослідимо результати моделювання за умови використання різних розмірів
податкових ставок та суми фіксованого податку.
** Експериментальне визначення оптимальної суми фіксованого податку
Зі створеною моделлю було виконано декілька експериментів для виявлення
найсприятливіших умов використання фіксованого податку, як такого, що вимагає
найменше бюрократичних операцій, а отже потенційно найменш придатний до різних
корупційних схем і, водночас, простіший у "використанні" як для платника, так
і для держави.

У всіх проведених дослідах більшість параметрів моделі було встановлена у
однакові значення, а варіювались лише податкові ставки. Фіксовані параметри
мали наступні значення:

- сітка розміром 33x33 (кількість клітин /N/ = 1156)
- вісім компаній (/M/ = 8)
- базова ймовірність "поломки" товару 3 відсотки (/d/ = 0.03)
- параметри функції корисності покупця: /a/ = 1, /p/ = -1 (тобто, враховується
  і локальна поширеність товару, і його ціна)
- один рік триває дванадцять ітерацій роботи автомату (/T/ = 12)
- початковий капітал держави тисяча одиниць капіталу, компанії починають з
  нульовим капіталом
- на підтримання існування клітини держава витрачає одну одиницю капіталу
  (/eg/ = 1), а компанія - двадцять (/ec/ = 20)
- початкова ціна товару у всіх компаній однакова і становить двадцять одиниць
  капіталу
- початкова схема оподаткування - податок на оборот для всіх компаній
- кожний експеримент тривав двісті п'ятдесят ітерацій

Також, на початку роботи моделі кожна компанія мала однакову кількість
покупців рівномірно розподілених по сітці автомату наступним чином
(світло-тілесним кольором виділені покупці без товару, інші вісім кольорів
відповідають восьми наявним компаніям):

[[./screenshots/economic_model_experiment_initial_state.png]]

Під час першого експерименту рівень податку на оборот був встановлений у п'ять
відсотків, податку на прибуток - десять відсотків, а фіксований податок
становив дві тисячі одиниць капіталу. Фінальний стан автомату виглядав
наступним чином:

[[./screenshots/economic_model_experiment_1.png]]

Результуючий капітал держави становив 2611491 одиниць капіталу, три відсотки
покупців були без товару, а показники компаній були наступні:

| № компанії | капітал | частина ринку, % | ціна | схема оподаткування |
|------------+---------+------------------+------+---------------------|
|          1 |  412949 |                8 |   29 | на прибуток         |
|          2 |  489895 |               11 |   29 | на прибуток         |
|          3 |  470440 |               13 |   44 | фіксований          |
|          4 |  476682 |               13 |   44 | на прибуток         |
|          5 |  301667 |                2 |   29 | на прибуток         |
|          6 |  339532 |                9 |   44 | фіксований          |
|          7 | 1409245 |               35 |   92 | фіксований          |
|          8 |  429412 |                1 |   29 | на прибуток         |

Як бачимо, сьома компанія завоювала більше третини ринку, а п'ята та восьма
майже зникли з нього. При цьому більшість компаній обрали податок на прибуток,
хоча й фіксований також мав деяке поширення, зокрема був обраний найбагатшою
сьомою компанією. Слід зазначити, що протягом роботи автомату в моменти
рівномірного розподілу ринку між компаніями домінував фіксований
податок. Середній капітал компанії становив 541227 одиниць капіталу, а середня
ціна товару - 42.

Для наступного експерименту рівень податку на оборот становив вісім відсотків,
податок на прибуток - двадцять відсотків, а фіксований податок - тисячу
п'ятсот одиниць капіталу. Експеримент завершився наступним станом автомату:

[[./screenshots/economic_model_experiment_2.png]]

Експеримент завершився з капіталом держави розміром 2607058 одиниць та такою
самою часткою покупців без товару, як і попередній (три відсотки). Показники
компаній були такі:

| номер компанії | капітал | частина ринку, % | ціна | схема оподаткування |
|----------------+---------+------------------+------+---------------------|
|              1 |  272234 |                9 |   29 | фіксований          |
|              2 |  514368 |               12 |   29 | фіксований          |
|              3 |  551082 |               12 |   44 | фіксований          |
|              4 |  154002 |                0 |   29 | на прибуток         |
|              5 |  808375 |               32 |   44 | фіксований          |
|              6 |  387382 |               12 |   44 | фіксований          |
|              7 |  361451 |                5 |   44 | фіксований          |
|              8 |  584177 |               11 |   44 | фіксований          |

Цього разу знову одна з компаній зайняла близько третини ринку (п'ята),
водночас, одна компанія взагалі була витіснена з ринку (четверта). Серед схем
оподаткування абсолютно домінує фіксований податок, при цьому середній капітал
компанії склав 454133 одиниць, а середня ціна товару - 39.

У порівнянні з попереднім експериментом фіксований податок став
найпоширенішим, зібрані державою кошти істотно не зменшились, а середня ціна
товару, навпаки, стала дещо меншою, водночас середні статки компаній стали не
такими великими (хоча й зменшився розрив між найбагатшою та найбіднішою
компаніями).

Зменшимо фіксований податок до п'ятисот одиниць не змінюючи при цьому
параметри інших податків. Фінальний стан автомату:

[[./screenshots/economic_model_experiment_3.png]]

Капітал держави склав 772422, а відсоток покупців без товару знову не
змінився - три відсотки. Показники ж компаній стали такі:

| номер компанії | капітал | частина ринку, % | ціна | схема оподаткування |
|----------------+---------+------------------+------+---------------------|
|              1 |  759421 |               28 |   29 | фіксований          |
|              2 |  480175 |               12 |   29 | фіксований          |
|              3 |  403934 |                0 |   66 | фіксований          |
|              4 |  327852 |                9 |   29 | фіксований          |
|              5 |  345665 |                8 |   19 | фіксований          |
|              6 |  605431 |               33 |   29 | фіксований          |
|              7 |  514635 |                0 |    9 | фіксований          |
|              8 |  489739 |                4 |   29 | фіксований          |

Цього разу дві компанії отримали приблизно по третині ринку (перша та шоста),
а дві зникли (третя та сьома), фіксований податок став єдиним, що
використовується, середній капітал досягнув 490856 одиниць, а середня ціна
товару - 27.

Таким чином, було отримано найменшу ціну товару (що добре для покупців) та
найбільший середній капітал компаній, водночас отримані державою гроші
зменшились більше, ніж в тричі. Спробуємо знайти компромісний варіант,
збільшивши фіксований податок до тисячі двохсот п'ятдесяти одиниць. Отримали
наступний фінальний вигляд автомату:

[[./screenshots/economic_model_experiment_4.png]]

Капітал держави склав 2023379, без товару залишилось два відсотки покупців. А
от фінальний стан компаній значно змінився:

| номер компанії | капітал | частина ринку, % | ціна | схема оподаткування |
|----------------+---------+------------------+------+---------------------|
|              1 |  430663 |               24 |   29 | фіксований          |
|              2 |  279634 |                0 |   56 | на оборот           |
|              3 |  879705 |               26 |   51 | фіксований          |
|              4 |  243732 |                0 |    9 | на оборот           |
|              5 |  482569 |               28 |   29 | фіксований          |
|              6 |  303563 |               16 |   20 | фіксований          |
|              7 |  394928 |                0 |   50 | фіксований          |
|              8 |  377015 |                0 |  168 | на оборот           |

Чотири компанії зникли з ринку, а інші чотири розділили ринок приблизно
порівну (одна з них мала трохи меншу частку покупців, а інші - майже
однакові). При цьому всі "живі" компанії використовували фіксований податок, а
середня ціна їх товарів сягнула 32. Середній капітал склав 423976 одиниці.

Бачимо, що результати другого експерименту є найзбалансованішими серед тих, де
фіксований податок домінує, тобто можна припустити, що розмір фіксованого
податку у тисячу п'ятсот одиниць є наближеним до оптимального для даної
моделі. Провівши нескладні підрахунки, на основі цих результатів можна
отримати одну з можливих формул для визначення фіксованого податку /ft/ для
нашої моделі:

/ft = 0.03 * N^{2} * avgPrice/

де /avgPrice/ - поточна середня вартість товару.

Проведемо ще один експеримент з динамічною зміною фіксованого податку: за
основу використаємо другий експеримент, і додамо туди ще одне правило обробки
інформації з вихідного каналу: за одну ітерацію до кінця кожного року за
наведеною формулою буде обраховуватись новий розмір фіксованого податку та
відправлятись команда у керуючий інформаційний канал про зміни цього податку
на нове значення. Отримані результати є доволі цікавими:

[[./screenshots/economic_model_experiment_5.png]]

Фінальні статки держави досягнули 1911748, а відсоток покупців без товару
повернувся до вже добре знайомого значення у три відсотки. Розмір фіксованого
податку на останній ітерації склав 968 одиниць, при цьому впродовж роботи
автомату він коливався в межах від 783 до 2450 одиниць.

| номер компанії | капітал | частина ринку, % | ціна | схема оподаткування |
|----------------+---------+------------------+------+---------------------|
|              1 |  144043 |               13 |   29 | фіксований          |
|              2 |  213365 |               15 |   29 | фіксований          |
|              3 |  114202 |                0 |    7 | на оборот           |
|              4 |  251794 |               22 |   29 | фіксований          |
|              5 |  122877 |               10 |   19 | на дохід            |
|              6 |  139140 |               12 |   19 | фіксований          |
|              7 |  166972 |               12 |   19 | на дохід            |
|              8 |  150882 |               10 |   19 | на дохід            |

Бачимо, що середній капітал компаній зменшився до 162909, а середня вартість
товару до 23, фіксований податок обрала половина компаній (слід зазначити, що
протягом роботи автомату всі компанії обирали лише фіксований податок, а інші
типи були обрані лише наприкінці заданого періоду симуляції). Але при цьому,
не враховуючи одної компанії, котра зникла з ринку, інші розділили покупців
приблизно порівну (друга та четверта "захопили" дещо більше за рахунок
"знищеної" третьої), тобто можна сказати, що залучення динамічного
фіксованого податку дозволили протримати модель у стані балансу довше, ніж
протягом попередніх експериментів.

Зрозуміло, що отримані результати є доволі синтетичним і не відображають усієї
складності реального життя, проте навіть за ними можна відстежувати певні
загальні тенденції у поведінці ринку та його реакцію на зовнішні зміни (зміну
податків). Потенційно ж, отриманий інструмент можна доволі легко зробити
більш потужним шляхом додавання додаткових зовнішніх команд (котрі здатні
гарно просимулювати втручання держави, наприклад, можливість встановлення
максимально можливої ціни товару), а також використанням більш "розумних"
клітин, котрі будуть виступати не лише покупцями, а й найманими робітниками,
що працюють на компанії. Також цікавим розширенням може бути додавання
динамічної зміни ставок й інших податків, а також опціональної здатності
уникнення компанією оплати податків з можливим отриманням штрафу на наступній
ітерації.
* Візуалізація клітинних автоматів
** React та ідея virtual DOM
React[8] - бібліотека від Facebook, створена для побудови компонованих
графічних HTML-інтерфейсів. На відміну від багатьох інших подібних рішень,
дана бібліотека цілковито відмовилась від звичних шаблонів (HTML документів
"покращених" додатковими директивами, котрі динамічно замінюються на
необхідний вміст) і натомість пропонує використовувати компоненти - фактично,
JavaScript функції, що генерують HTML-розмітку, та дотримуються певних
вимог. Кожний компонент приймає як параметри два елементи - =props= (незмінні
дані) та =state= (змінні дані).

Ключовою особливістю React є те, що бібліотека автоматично підтримує
відображення у актуальному стані - компонент перемальовується у випадку зміни
даних, що використовуються ним. На перший погляд це здається надто повільним,
проте розробники використали цікавий підхід, котрий можна назвати virtual
DOM. Під час першої ініціалізації компоненту викликається метод =render=,
котрий генерує легковісне представлення відображення, з якого створюється
рядок з HTML-розміткою та додається у тіло документу. Надалі виклики методу
=render= призводять до повторної генерації проміжного представлення, котре
порівнюється з попереднім варіантом, з порівняння знаходиться мінімальний
набір змін, котрі необхідну виконати для перетворення попереднього
відображення у поточний варіант. Перетворюються у розмітку та застосовуються
вже ці, переважно невеликі, зміни. Можна сказати, що компонент у React - це
простий скінченний автомат, котрий генерує різне відображення в залежності від
поточного стану (значення даних, що використовуються компонентом).

Обробники подій додаються до компонентів просто як HTML-властивість певного
DOM-елементу, ключем якої є ім'я події у camelCase, а значенням - функція, що
оброблюватиме подію. У React імплементована своя система обробки подій, котра
намагається забезпечувати сумісність зі специфікацією W3C в незалежності від
броузеру, що використовується. Додатково для всіх обробників значення
JS-контексту автоматично встановлюється у поточний компонент. Також,
використовується делегація подій - обробники приєднуються не безпосередньо до
відповідних DOM-елементів, а створюється один загальний обробник, котрий
приєднується до кореневого елементу і викликає необхідний користувацький
обробник в залежності від події, що відбулась.

Компоненти бібліотеки є модульними - кожен з них може бути частиною іншого
компоненту та містити компоненти у собі. Якщо компонент містить інші
компоненти, він є їх власником та відповідальний за заповнення =props= всіх
компонентів, що "належать" йому. Більш формально, компонент є власником всіх
компонентів, що створюються у його =render=-методі.

Кожен компонент обов'язково має визначити метод =render= - генерує опис одного
DOM-елементу, котрий мусить бути відображеним на сторінці. Даний метод має
бути чистим (як у понятті чиста функція) - якщо на вхід подаються однакові
параметри, результат має також бути однаковим. Водночас, React визначає доволі
детальний життєвий цикл компонентів, для модифікації обробки кожного з його
етапів достатньо додатково визначити відповідний метод під час опису
компоненту. Передбачені наступні фази:

- =getInitialState= :: викликається один раз перед додаванням компоненту у
     DOM; значення, що повертається, використовується як початкове для =state=
- =getDefaultProps= :: викликається один раз перед додаванням компоненту у
     DOM;значення, що повертається, використовується як початкове для =props=
- =componentWillMount= :: викликається один раз перед додаванням компоненту у
     DOM
- =componentDidMount= :: викликається одразу після додавання компоненту у DOM
- =componentWillReceiveProps= :: викликається під час отримання компонентом
     нових =props=, але перед генерацією нового відображення
- =shouldComponentUpdate= :: викликається перед генерацією відображення після
     отримання нових =props= або =state=; якщо метод повертає =false=,
     генерація нового відображення не буде проводитись
- =componentWillUpdate= :: викликається перед генерацією нового відображення
     після отримання нових =props= або =state=
- =componentDidUpdate= :: викликається одразу після генерації нового
     відображення після отримання нових =props= або =state=
- =componentWillUnmount= :: викликається перед тим, як компонент буде
     видалений з DOM

Для опису HTML-елементів всередині компонентів пропонується набір функцій з
простору імен =React.DOM=, кожна з яких відповідає певному HTML-тегу:
наприклад, посилання створюється наступним чином:

#+BEGIN_SRC javascript
var link = React.DOM.a({href: 'http://google.com'}, 'Google');
#+END_SRC

Також розробники створили простий трансформатор синтаксису JavaScript-файлів
JSX, котрий дозволяє створювати HTML-елементи у JavaScript-коді майже так
само, як у звичайних HTML-файлах. Наприклад, попередній приклад буде виглядати
так:

#+BEGIN_SRC javascript
/** @jsx React.DOM */

var link = <a href="http://google.com">Google</a>
#+END_SRC

Коментар на початку обов'язковий, він виконує функцію аналогічну
=pragma=-конструкціям у С++, вказуючи інтерпретатору виконати трансформацію
синтаксису перед інтерпретацією.

Для прив'язки створеного компонента до елемента на сторінці використовується
функція =React.renderComponent=, першим параметром якої є компонент, а
другим - DOM-елемент, до якого компонент має бути прив'язаним. Наведемо
приклад створення та прив'язки композитного компоненту - списку коментарів
від різних авторів[9]:

#+BEGIN_SRC javascript
/** @jsx React.DOM */

var data = [
  {author: "Pete Hunt", text: "This is one comment"},
  {author: "Jordan Walke", text: "This is *another* comment"}
];

var Comment = React.createClass({
  render: function() {
    return (
      <div className="comment">
        <h2 className="commentAuthor">
          {this.props.author}
        </h2>
        {this.props.children}
      </div>
    );
  }
});

var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function (comment) {
      return <Comment author={comment.author}>{comment.text}</Comment>;
    });
    return (
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});

var CommentBox = React.createClass({
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.props.data} />
      </div>
    );
  }
});

React.renderComponent(
  <CommentBox data={data} />,
  document.getElementById('content')
);
#+END_SRC

Компонент =CommentBox= є кореневим компонентом, він приймає на вхід список
коментарів та передає їх компоненту =CommentList=, котрий перетворює кожний
елемент списку у компонент =Comment= та відображає їх одним списком.

** ClojureScript та Om
Для реалізації застосування використовувалась мова програмування
ClojureScript. Вона є варіантом мови Clojure, котрий запускається не на JVM, а
компілюється у JavaScript. Хоча й ClojureScript не має всіх можливостей мови
Clojure (зокрема, багатопоточності), але підтримує базову семантику даної
мови, зокрема незмінні структури даних, "ліниві" послідовності, функції вищого
порядку, простори імен та навіть макроси. Основна відмінність між Clojure та
ClojureScript - якщо перша мова працює спільно з Java та має можливості
інтероперабельності з саме цією мовою, то друге вже використовує JavaScript у
ролі "батьківського" середовища та інтероперує з ним.

ClojureScript генерує немініфікований та необфускований JavaScript код, котрий
надалі передається на вхід Google Closure Compiler[5], котрий і оптимізує
отриманий код. Разом з компілятором до складу Google Closure входить набір
низькорівневих бібліотек для більшості буденних задач, що виникають під час
розробки JavaScript застосувань - наприклад, надсилання запитів до
сервера. ClojureScript надає до них повний доступ без необхідності їх
додаткового завантаження та додавання на сторінку.

Цікавою особливістю є те, що і компілятор ClojureScript, і компілятор Google
Closure запускається на JVM - перший компілятор написаний на Clojure, а другий
на Java. Загалом процес перетворення ClojureScript у готовий до використання
JavaScript код відбувається наступним чином[6]:

[[./cljs_compilation.png]]

Генерація HTML-відображення у застосуванні здійснюється за допомогою
бібліотеки Om[7]. Вона є обгорткою над розглянутою раніше JS-бібліотекою
React, а також додає власну модель збереження стану застосування.

Om, як і React, пропонує використовувати незалежні, але зв'язані один з одним,
компоненти, проте на відміну від React, всі дані, що передаються між
компонентами є незмінними. Завдяки цьому та особливостям реалізації
незмінності у Clojure/ClojureScript вдається досягти ще більшої швидкості
роботи, адже для визначення того, чи потрібно перемальовувати компонент
достатньо порівняти указники параметрів, а не їх вміст.

Всі дані, необхідні для генерації відображення, зберігаються у одному
кореневому контейнері, котрий змінюється за допомогою механізму
транзакцій. Зазвичай контейнером виступає звичайний асоціативний масив, що має
деревоподібну структуру (тобто, має багато вкладених асоціативних масивів),
кожна "гілка" цього масиву використовується одним з (або декількома)
компонентами, що входять до складу застосування.

Всередину компоненту передається не сам контейнер з даними, а так званий
курсор, що описує певний шлях всередину контейнеру (на концептуальному рівні
курсор схожий на таке поняття зі сфери структур даних як zipper). Фактично,
курсор обмежує область видимості даних для компонента лише необхідними йому
даними, водночас зберігає можливість оновлювати ці дані з компоненту, не
знаючи про загальну структуру контейнера з даними.

Для кожного з етапів життєвого циклу компоненту React передбачений бібліотекою
передбачений свій протокол - для того, щоб визначити особливу поведінку під
час конкретного етапу, достатньо реалізувати відповідний протокол. Кожний
Om-компонент має визначити щонайменше протокол, котрий описує render-фазу
(безпосередню генерацію HTML, протокол IRender або IRenderState). Під час
створення екземпляру компонента йому обов'язково передається курсор на певну
частину загального контейнера з даними. Дані з курсору доступні напряму під
час фази render, проте під час інших фаз до них можна звертатись лише як до
атому (один з базових елементів Clojure/ClojureScript) - попередньо потрібно
"розіменувати" (dereference) посилання, котрим, по суті, є курсор.

Для генерації HTML можна використовувати стандартне API React'у =React.DOM=
(що і було обрано для даної роботи), також існує декілька Om-специфічних
додаткових бібліотек.

Прив'язка компоненту до DOM-елементу здійснюється за допомогою функції
=om/root=, котра дещо відрізняється від варіанту React. Першим аргументом так
само приймається компонент, а от другим вже виступає контейнер з даними. Також
приймається третій параметр - асоціативний масив з додатковою конфігурацією,
зокрема DOM-елементом, до якого слід прив'язати компонент.

Наведемо Om-компоненти, що відповідають вищеописаному прикладу для React:

#+BEGIN_SRC clojure
(ns example
  (:require [om.core :as om :include-macros true]
            [om.dom :as dom :include-macros true]))

(def data (atom [{:author "Pete Hunt" :text "This is one comment"}
                 {:author "Jordan Walke" :text "This is *another* comment"}]))

(defn comment [comment owner]
  (reify
    om/IRender
    (render [this]
      (dom/div #js {:className "comment"}
        (dom/h2 #js {:className "commentAuthor"} (:author comment))
        (:text comment)))))

(defn comment-list [comments owner]
  (reify
    om/IRender
    (render [this]
      (dom/div #js {:className "commentList"}
        (om/build-all comment comments)))))

(defn comment-box [data owner]
  (reify
    om/IRender
    (dom/div #js {:className "commentBox"}
      (dom/h1 nil "Comments")
      (om/build comment-list data))))

(om/root comment-box data
  {:target (. js/document (getElementById "content"))})
#+END_SRC

Цікавою відмінністю від Om від React'у є обробники подій. Якщо в останньому
зазвичай обробник подій несе у собі безпосередню логіку, котра має виконатись
у відповідь на події, в Om часто використовують інший підхід - обробник лише
переправляє інформацію про подію в канал даних, створений за допомогою
реалізації CSP для Clojure/ClojureScript. Обробка нових повідомлень у каналі
зазвичай відбувається у "батьківському" компоненті, в якому і створюються всі
необхідні канали: їх створення відбувається під час фази =getInitialState=, а
додавання обробників повідомлень з каналів - під час
=componentWillMount=. Таким чином можливе значно спростити код
компонентів-дітей (бо вся їх логіка це просто пересилання повідомлень), і
зосередити обробку всіх подій в одному місці. Загалом, даний підхід досить
схожий на PubSub, проте й має свої особливості. Розглянемо його детальніше в
наступному розділі.
** Communicating Sequential Processes та core.async
Communicating Sequential Processes - формальна мова опису схем взаємодії у
паралельних системах, котра є представником так званих алгебр процесів
(process calculi) і базується на передачі повідомлень каналами
(channel). Вперше CSP було описано у 1978 році в роботі C. A. R. Hoare.[10]

Найяскравішими представниками підходу є мови програмування occam, Limbo, Go та
бібліотека =core.async=. Донедавна підхід рідко використовувався у практичних
задачах, але відносно часто залучався для специфікації та верифікації
паралельних аспектів складних систем, наприклад мікропроцесора INMOS T9000
Transputer. Цікавим використанням було моделювання системи управління
відмовами створеної для використання на Міжнародній Космічній станції, котре
проводилось Бременським інститутом безпечних систем та Daimler-Benz
Aerospace - за допомогою CSP дослідники довели, що їх система не містить
deadlock'ів та livelock'ів. При цьому під час процесу моделювання та аналізу
було виявлено певну кількість помилок, котрі не могли бути знайдені звичайними
тестами. Схожим чином Praxis High Integrity Systems залучило CSP для
верифікації своєї системи Certification Authority для смарт-карт - компанія
стверджує, що завдяки цьому їх рішення має набагато менший рівень відмов, ніж
пропозиції конкурентів.

В останні роки CSP починають все частіше використовувати і у повсякденних
прикладних задачах (як от, побудова асинхронних веб-застосувань, графічних
інтерфейсів), насамперед через поширення мови програмування Go, модель
паралельності якої повністю будується на даному підході.

CSP дозволяє описувати системи як набір незалежних компонент-процесів, котрі
взаємодіють один з одним лише за допомогою передачі повідомлень. Взаємодія між
процесами один з одним та з середовищем описується за допомогою спеціальних
операторів алгебри процесів. Поєднуючи декілька основних примітивів різним
чином, можливо легко описувати навіть доволі складні системи.

Існує два основних класи примітивів:

- події :: акт спілкування або взаємодії. Вважається, що вони є неподільними
           та миттєвими.
- примітивні процеси :: процеси, що описують базову поведінку, наприклад, STOP
     (процес, що нічого не передає - deadlock) та SKIP (описує успішне
     завершення роботи)

Найважливішими операторами є:

- префікс :: поєднує подію і процес, породжуючи новий процес. Наприклад, a -> P
             описує процес, що чекає на подію а, а після цього поводиться як
             процес P
- детермінований вибір :: описує процес, робота якого розвивається за двома
     різними шляхами в залежності від того, яка події надійде з
     оточення. Наприклад, якщо відбувається подія a буде виконуватись процес
     P, а якщо подія b - то процес Q
- недетермінований вибір :: схожий на попередній, але розвиток процесу не
     залежить від оточення, а чекає на те, поки відбудуться обидві події, а
     потім "самостійно" (в залежності від внутрішнього стану системи)
     визначає, яку гілку виконання обрати
- перетинання (interleave) :: описує процес, що поєднує в собі незалежну
     одночасну роботу двох інших процесів
- паралельний інтерфейс (interface parallel) :: процес, що поєднує в собі
     роботу одночасну роботу двох інших процесів, при цьому вони мусять
     синхронізуватись один з одним - вказані в операторі події можуть бути
     оброблені, лише коли обидва процеси здатні їх обробити
- сховування (hiding) :: описує процес, котрий не оброблює вказані події, які
     оброблюються базовим процесом

Хоча дана теорія доволі схожа з моделлю акторів, існує декілька
фундаментальних відмінностей у примітивах, що використовуються у даних
підходах:

- процеси в CSP анонімні, а актори мають "ідентичність";
- в CSP передача повідомлень вимагає явної "зустрічі" між відсилачем та
  отримувачем повідомлення - повідомлення не може бути надіслане допоки нема
  отримувача, здатного його прийняти. Натомість, в моделі акторів надсилання
  повідомлень є повністю асинхронним;
- CSP використовує явні канали для передачі повідомлень, а модель акторів
  передає їх іменованим отримувачам (акторам).

Як вказувалось раніше, в моєму застосуванні використовується реалізація CSP
для мови програмування Clojure/ClojureScript, а саме бібліотека
=core.async=. Вона надає можливість асинхронного програмування за допомогою
каналів. Основними задачами бібліотеки є:

- надати інструменти для незалежних потоків дій, що взаємодіють за допомогою
  подібних до черг каналів;
- підтримка "справжніх" потоків та сумісного використання потоків з пулу;
- базуватись на CSP, водночас розвиваючи її.[11]

Як було сказано раніше про CSP, головною ознакою каналів є те, що вони
блокуючі. Водночас, бібліотека надає можливість створювати буферизовані
канали, здатні приймати задану кількість повідомлень без необхідності їх
моментального отримування.

Використання бібліотеки у Clojure та ClojureScript дещо відрізняється, так як
моє застосування написане на ClojureScript, надалі зосередимось на розгляді
API саме цієї версії.

Використання бібліотеки починається з імпортування визначених у ній функцій:

#+BEGIN_SRC clojure
(require-macros '[cljs.core.async.macros :refer :all])
(require '[cljs.core.async :refer :all])
#+END_SRC

Для створення каналу використовується наступна функція:

#+BEGIN_SRC clojure
(chan)
#+END_SRC

Створений канал можливо "закрити" - він перестає приймати в себе нові
повідомлення, але ті, що вже в ньому присутні, все що доступні для
читання. Коли всі повідомлення з каналу вичерпані, він повертає nil.

#+BEGIN_SRC clojure
(close! (chan))
#+END_SRC

Так як JavaScript однопоточний, бібліотека використовує аналог легковісних
потоків для створення уявлення багатопоточної обробки повідомлень. Для цього
операції треба "огортати" код у спеціальний макрос =go=, котрий передає дії на
асинхронне виконання, повертає інший канал, в якому з'явиться результат
операцій і дозволяє програмі продовжувати своє виконання. Базовими операціями
над каналом є запис та читання повідомлень:

#+BEGIN_SRC clojure
(let [c (chan 3)]
  (go (>! c "hello")
      (<! c)))
#+END_SRC

Якщо потрібно чекати на появу повідомлення в одному з декількох каналів, можна
використовувати операцію alts!:

#+BEGIN_SRC clojure
(let [c1 (chan)
      c2 (chan)]
  (go (while true
        (let [[v ch] (alts! [c1 c2])]
          (println "Read" v "from" ch))))
  (go (>! c1 "hi"))
  (go (>! c2 "there")))
#+END_SRC
** Огляд виконаної реалізації
Застосування було виконано у формі так званого single-page application, при
чому серверна частина у нього відсутня, всі обрахунки відбуваються на
клієнтській стороні. Як зазначалось у попередніх розділах, застосування
написане на мові ClojureScript з використанням бібліотеки Om для генерації
HTML та його відображення, core.async для взаємодії компонентів застосування,
також був використаний CSS-фрейморк Bootstrap для надання стандартним
HTML-елементам більш гарного зовнішнього вигляду. Для базових функцій
клітинного автомату були написані генераційні тести за допомогою бібліотек
clojurecript.test та double-check, код візуалізації не тестувався.

Код застосування зберігається у хостингу репозиторіїв GitHub як проект з
відкритим кодом [[https://github.com/gsnewmark/beatha]], а саме скомпільоване
застосування розміщене у публічному доступі за допомогою безкоштовного сервісу
хостингу статичних сторінок GitHub Pages і доступне за посиланням
[[http://gsnewmark.github.io/beatha/]]. При кожному оновленні коду на GitHub
автоматично запускаються тести, а також компілюється весь проект та
завантажується на GitHub Pages (якщо тести закінчились успішно) за допомогою
сервісу Travis-CI. Таким чином у мережі завжди доступний не лише вихідний код,
а й найсвіжіша працююча версія застосування.

Застосування складається з двох основних екранів: головне меню та відображення
обраного клітинного автомату. Кожний з екранів є окремим Om-компонентом. При
запуску застосування спершу показується головне меню. Воно містить кнопки
запуску одного з трьох можливих клітинних автоматів:

[[./screenshots/main_menu.png]]

Перша кнопка запускає звичайний варіант Game of Life без будь-якого розширення
інформаційними каналами. Друга - розпізнавач необмеженої граматики, а третя -
модель економічних відносин. Через свою допоміжну роль, компонент виконаний не
у звичному для Om стилі, а дещо спрощений: обробники натискань на кнопки
викликають відображення наступного екрану напряму, це відображення
відбувається шляхом знищення поточного екрану з DOM-елементу та відмальовки
наступного екрану у цьому ж DOM-елементі. Розглянемо детальніше кожен з
наявних клітинних автоматів.

Екран з реалізацією Game of Life надає базові можливості взаємодії з клітинним
автоматом:

[[./screenshots/game_of_life_annotated.png]]

Згори знаходиться кнопка (1), котра дозволяє знищити поточний автомат та
повернутись у головне меню.

У правій частині екрану знаходиться показник поточної ітерації (5) та сітка
автомату (6). Вона може перебувати у двох станах - налаштування та
симуляція. У стані налаштування можливо змінювати певні глобальні параметри
сітки автомату (розглянуто далі), а натиснення на комірку призводить до зміни
її поточного стану на наступний: для Game of Life таких стани два - мертвий
(клітина сірого кольору) та живий (клітина зеленого кольору), за замовченням
всі клітини мертві. У режимі симуляції сітка вже не сприймає натиснення на
себе користувачем, а покроково змінює свій стан відповідно до правил автомату
кожні пів секунди. Для Game of Life правила наступні:

#+BEGIN_SRC clojure
(cond
  (and alive? (or (< n 2) (> n 3))) {:state :dead}
  (and alive? (or (= n 2) (= n 3))) {:state :alive}
  (and (not alive?) (= n 3))        {:state :alive}
  :else                             cell)
#+END_SRC

де =n= - кількість живих сусідів (використовується "сусідство" Мура), =cell=
поточний стан клітини, =alive?= - булевий вираз, що описує поточний стан
клітини (чи клітина жива).

У лівій частині екрану розміщується блок налаштування клітинного автомату,
котрий складається з наступних частин:

2. Кнопка запуску/зупинки роботи автомату ("Start") - якщо автомат ще не у
   режимі симуляції переводить його у цей режим, інакше - зупиняє симуляцію та
   переводить автомат у режим налаштування.
3. Блок налаштування розмірності сітки - дозволяє змінити кількість стовпчиків
   та рядків комірок сітки. У поля заноситься бажана розмірність сітки, а
   кнопка оновлює сітку відповідно до введених значень, при чому стан сітки
   скидається у початковий (всі клітини "мертві"). Доступно лише у режимі
   налаштування.
4. Блок налаштування візуального розміру сітки - дозволяє вказати скільки
   пікселів по ширині та висоті займає сітка на екрані. У поля заноситься
   бажана ширина та висота, а натиснення кнопки призводить до їх реальної
   зміни. Доступно лише у режимі налаштування.

Кожен з вищеописаних елементів є самостійним Om-компонентом, котрі об'єднані в
одному батьківському, в якому зосереджений код обробки подій та описане
взаємне розміщення компонентів-дітей. Початковий загальний стан застосування
описується наступним чином:

#+BEGIN_SRC clojure
(def app-state {:automaton {:grid {:width 10 :height 10 :cells {}}
                            :display {:width 580 :height 580}
                            :util {:started false :iteration 0}}
                :command {}})
#+END_SRC

Асоціативний масив складається з двох основних частин: =command= - містить
специфічну для задачі інформацію стосовно керуючого каналу та =automaton= -
містить безпосередньо асоціативний масив з інформацією про сам клітинний
автомат. У ньому під ключем =grid= зберігається ще один асоціативний масив,
який містить поточну розмірність сітки, а також асоціативний масив з
клітинами - ключем цього масиву є вектор з координатою клітини (наприклад, =[1
1]=), а значенням - специфічне для конкретного автомату представлення стану
клітини (для Game of Life це ={:state :alive}=), як зазначалось раніше,
клітини зі "стандартним" станом у даному масиві не зберігаються (для Game of
Life це мертві клітини). Під ключем =display= зберігається ширина та висота
сітки у пікселях, а під ключем =util= - допоміжна інформація: =started=
містить булеву змінну, котра визначає чи знаходиться автомат у режимі
симуляції, а =iteration= - номер поточної ітерації.

Батьківський компонент визначає сім core.async каналів:

- =change-grid-dimensions= :: оброблює зміну розмірності автомату,
     заповнюється повідомленнями під час натиснення на кнопку з блоку 3,
     повідомлення містить двохелементний вектор з новою логічною шириною та
     висотою сітки
- =change-display-dimensions= :: оброблює зміну візуального розміру сітки,
     заповнюється повідомленнями під час натиснення на кнопку з блоку 4,
     повідомлення містить двохелементний вектор з новою шириною та висотою
     сітки
- =cell-state-changed= :: змінює стан заданої клітини відповідно до правил
     автомату, повідомлення надсилаються з основного циклу застосування кожні
     пів секунди для кожної клітини автомату, повідомленням є двохелементний
     вектор з координатами клітини, стан якої потрібно змінити на наступний
- =started= :: змінює режим роботи автомату на симуляцію або налаштування,
               заповнюється повідомленнями під час натиснення на кнопку з
               блоку 2, повідомлення містить булеву змінну
- =reset= :: скидає параметри автомату у значення за замовченням, заповнюється
             повідомленнями обробником повідомлень для каналу
             =change-grid-dimensions= (при зміні розмірності сітки), а також
             кодом, специфічним для певних автоматів
- =output-info-channel=, =command-info-channel= :: оброблюють повідомлення з
     вихідного та керуючого інформаційних каналів відповідно, будуть
     розглянуті пізніше

Батьківський компонент розроблений таким чином, щоб візуалізувати роботу
довільного клітинного автомату, а не якогось конкретного. Для цього були
створені два протоколи, реалізувавши які опис клітинного автомату може бути
візуалізований створеним компонентом.

Перший протокол описує загальну роботу клітинну автомату.

#+BEGIN_SRC clojure
(defprotocol AutomatonSpecification
  "Describes basic interactions with particular set of cellular automata
  rules."
  (default-cell [this] "Default cell of the given automata.")
  (next-initial-state [this state]
    "Returns next possible initial state after the given one.")
  (next-grid [this grid]
    "Transforms given grid according to automata's rules."))
#+END_SRC

Функція =default-cell= повертає опис комірки за замовченням (котра, не має
зберігатись у пам'яті). =next-initial-state= здійснює перебирання початкових
станів, приймаючи на вхід певний стан, повертає наступний, що слідує за
ним. Використовується дана функція у режимі налаштування для створення
початкової конфігурації автомату. Остання функція =next-grid= є основною -
отримавши на вхід опис поточної сітки автомату, генерує її наступну ітерацію
(як згадувалось раніше, сітка описується асоціативним масивом з ключами
=width=, =height=, =cells=).

Другий протокол описує розроблену модифікацію клітинного автомату, у Game of
Life він, фактично, не використовується (містить реалізацію-заглушку).

#+BEGIN_SRC clojure
(defprotocol InformationChannelsSpecification
  "Describes interactions with information channels which augment the regular
  cellular automata:

    - command channel is a source of external commands which augment rules of
      automata;
    - output channel is filled by the automata itself with aggregate
      information about current state."
  (process-command-channel [this ic]
    "Handles messages from the command information channel.")
  (fill-output-info-channel [this oc grid]
    "Sends a message about the current automata's state."))
#+END_SRC

Перша функція, =process-command-channel= приймає на вхід core.async канал,
котрий моделює керуючий інформаційний канал та має специфічним для конкретного
автомату чином оброблювати команду, що приходять у даний канал. А друга,
=fill-output-info-channel=, приймає на вхід поточний стан сітки автомату, а
також core.async канал, що описує вихідний інформаційний канал, і має
надіслати певне повідомлення про агрегований стан сітки на цей канал.

Наступний автомат - парсер необмеженої граматики, використовує модифікацію
автомату за допомогою цих інформаційних каналів, і тому зовнішній вигляд
екрану з автоматом для нього дещо відрізняється:

[[./screenshots/parser_annotated.png]]

До попереднього варіанту відображення додаються два нові блоки:

1. Відображення повідомлень з вихідного інформаційного каналу - для парсера у
   цьому блоці з'являється повідомлення про те, чи належить задане слово
   граматиці (відповідно, буде виведено одне з повідомлень "Result: word is
   parsed" або "Result: word is not parsed"). Якщо на вихідний канал ще не
   приходило повідомлень, блок не показується. Для обробки цих повідомлень
   парсер додає у загальний стан застосування ще один ключ =result=, котрий
   містить булеву змінну, яка показує чи успішно закінчився процес
   розпізнавання.
2. Блок надсилання команд - містить засоби надсилання на керуючий
   інформаційний канал автомату команд. Для парсера у блоці розміщується
   чекбокси, що дозволяють сформувати команду (дві опції, які можна вибрати
   водночас - використовувати літеру "a" як wildcard, використовувати літеру
   "b" як wildcard), а також кнопка для надсилання сформованої команди та
   очищення автомату від попередньо надісланої команди (відміняє її
   дію). Даний блок доступний як в режимі налаштування, так і в режимі
   симуляції, завдяки чому команди можна надсилати вже під час роботи
   автомату.

Зрозуміло, що робота з інформаційними каналами для кожного автомату буде своя,
тому батьківський Om-компонент за замовченням не містить компонентів-дітей
для відображення даної взаємодії. Натомість, він приймає опціональний
параметр - реалізацію ще одного протоколу, котра визначає складові елементи
такого відображення, і інтегрує ці елементи у загальний інтерфейс. Зокрема,
використовує функції з цього протоколу для обробки повідомлень з раніше
згаданих каналів =output-info-channel= (заповнюється у головному циклі
застосування на кожному кроці роботи автомату, повідомлення відповідають
повідомленням, що надіслані у вихідний інформаційний канал),
=command-info-channel= (заповнюється компонентом, що відповідає за керуючий
інформаційний канал, повідомлення містять команди, що надсилаються у
автомат). Протокол виглядає наступним чином:

#+BEGIN_SRC clojure
(defprotocol CellularAutomatonAppCustomization
  (automaton-specific-css [this data]
    "Return additional CSS rules for given automaton that should be added
    to the page.")
  (automaton-configuration-view [this]
    "Genrates Om component that renders automaton-specific configuration
    block.")
  (automaton-command-view [this]
    "Generates Om component that renders block for sending commands to
    automaton. Please ensure the same component is returned on each call and
    the new one is generated (i. e., anonymous function).")
  (automaton-command-initial-state [this]
    "Returns the default stated for the command view.")
  (automaton-command-reset [this command-info-channel]
    "Resets any changes created by the command sent to the automata.")
  (automaton-output-handler [this data owner msg]
    "Handles messages posted by the cellular automaton.")
  (automaton-output-view [this]
    "Generates Om component that renders any changes produced by
    the handler. Please ensure the same component is returned on each call and
    the new one is generated (i. e., anonymous function).")
  (automaton-output-reset [this data owner]
    "Resets changes produced by the handler."))
#+END_SRC

Функція =automaton-specific-css= дозволяє додати на сторінку додаткові
глобальні CSS-правила, специфічні для певного автомату. Насамперед
використовується, якщо необхідно генерувати динамічні правила на основі певних
параметрів автомату. Наступна функція, =automaton-configuration-view= визначає
Om-компонент, котрий використовується для налаштування специфічних для
автомату параметрів (приклад буде наведено далі). Функція
=automaton-command-view= має повернути компонент, котрий відображає блок
надсилання команд, =automaton-command-reset= відміняє дію команди на автомат
(за замовченням викликається під час зміни розмірності автомату),
=automaton-output-handler= оброблює повідомлення, що надходять у створений
батьком канал =output-info-channel=, =automaton-output-view= повертає
компонент, котрий відображає блок візуалізації повідомлень з вихідного
інформаційного каналу, =automaton-output-reset= переводить створений минулою
функцією компонент у початковий вигляд (за замовченням викликається під час
зміни розмірності автомату).

Останній автомат - економічна модель, окрім модифікацій інтерфейсу присутніх у
попередньому автоматі, дана модель використовує додатковий блок конфігурації,
специфічної для автомату (=automaton-configuration-view= з щойно розглянутого
протоколу):

[[./screenshots/economic_model_annotated.png]]

Надається можливість задати наступні додаткові параметри автомату:

- кількість компаній :: скільки компаній приймають участь у ринковій боротьбі
- тривалість "року" :: зі скількох ітерацій роботи автомату складається
     економічний "рік"
- кількість виконаних ітерацій :: як довго модель має працювати до зупинки

Кожна клітина автомату відповідає покупцю, а її стан показує товар якої
компанії придбаний даним користувачем. Так як кількість компаній є параметром,
то й кількість станів клітини не є відомою наперед - через це даний автомат
використовує генерацію додаткових CSS-стилів (=automaton-specific-css=):
перед запуском моделі для кожного стану підбирається унікальний колір, котрий
описується у окремому CSS-правилі.

Блок надсилання команд даного автомату є більш складним, ніж у
розпізнавача мови:

[[./screenshots/economic_model_command.png]]

Він дозволяє редагувати широкий набір параметрів алгоритму, а
саме розмір відсоткових ставок на оборот та прибуток, величину фіксованого
податку, ймовірність відмови від поточного товару, а також параметри функції
корисності покупця (=a= - внесок локальних вподобань та =p= - внесок ціни
товару).

Більш цікавим є і блок відображення даних з вихідного інформаційного каналу:

[[./screenshots/economic_model_output.png]]

На ньому можна в реальному часі бачити детальну інформацію про стан
автомату: рівень грошових запасів уряду та компаній, поточний розподіл ринку у
відсотках, ціни на товар від різних компаній, обрану кожною компанією схему
оподаткування, а також поточні усіх значення параметрів, що надсилаються
командою. Цікавою особливістю є те, що для легшої візуальної ідентифікації всі
показники певної компанії додатково виділяються таким самим кольором, що і
відповідний стан клітини автомату.

Обраний для створення графічного інтерфейсу інструмент хоч і є доволі молодим
та малопоширеним виявився надзвичайно зручним у використанні та
підтримці. Завдяки обраній у Om моделі збереження та поширення даних особливих
проблем не викликає створення універсальних компонентів, що з легкістю можуть
бути використані для побудови подібних, проте все-таки різних інтерфейсів, а
водночас і залишає можливість налаштування елементів під конкретний випадок
(створення, умовно кажучи, компонентів вищого порядку). Зокрема, у створеній
програмі інтерфейс усіх трьох автоматів базується на єдиному базовому
компоненті котрий, за необхідності, розширяється додатковими
підкомпонентами.

У процесі розробки деякі елементи інтерфейсу частково переписувались декілька
разів: завдяки явній ставці на повну незалежність компонентів один від одного
та їх спілкування за допомогою каналів core.async навіть відсутність статичної
типізації та зміна вигляду вихідного коду, що безпосередньо потрапляє на
сторінку, унаслідок компіляції Google Closure не склали значних перепон для
безболісної зміни частин загальної системи. Загалом, використання Om та React,
а також core.async виявилось незвичним, але продуктивним, підходом до
створення веб-інтерфейсів.
* Висновки
В рамках даної магістерської роботи я дослідив розширення клітинних автоматів
двома додатковими інформаційними каналами, котрі роблять автомат більш
придатним для моделювання нетривіальних систем.

Як практичну частину було створено розпізнавач необмеженої формальної мови, а
також модель економічної взаємодії компаній, держави та покупців на ринку
високотехнологічних послуг.

Для візуалізації створених автоматів я ознайомився з новітньою бібліотекою
створення веб-інтерфейсів користувача від Facebook React та її
ClojureScript-обгорткою Om. Був розглянутий і засіб асинхронного програмування
на основі CSP core.async. Використовуючи перелічені технології було створено
single-page веб-застосування здатне відображати роботу довільного клітинного
автомату прямокутної форми. Додатково застосування надає можливість
налаштовувати відображення інформації з вихідного інформаційного каналу,
зв'язаного з автоматом, та блоку надсилання команд на керуючий інформаційний
канал даного автомату.
* Список літератури
1. Клеточные автоматы. Реализация и эксперименты - Лев Наумов, Анатолий Шалыто
2. Modelling the Spatial Dimension of Economic Systems with Cellular
   Automata - Max Keilbach
3. https://en.wikipedia.org/wiki/Cellular_automaton
4. Clojure Programming - Chas Emerick, Brian Carper, Christophe Gran
5. https://developers.google.com/closure/
6. ClojureScript Up and Running - Stuart Sierra, Luke VanderHart
7. https://github.com/swannodette/om
8. http://facebook.github.io/react/blog/2013/06/05/why-react.html
9. http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html
10. https://en.wikipedia.org/wiki/Communicating_sequential_processes
11. http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html
12. http://en.wikipedia.org/wiki/Unrestricted_grammar
