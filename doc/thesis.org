#+TITLE: Моделювання процесів за допомогою модифікованих клітинних автоматів
#+LANGUAGE: uk
#+AUTHOR: Іван Криворучко

* Вступ
* Постановка задачі
В рамках даної роботи буде досліджено можливість розширення стандартних
клітинних автоматів двома додатковими каналами даних. Один з них розповсюджує
певну команду на всі клітини, кожна така команда змінює функцію переходу
клітини в обхід звичних правил клітинного автомату, а другий - на кожному
кроці певним чином агрегує інформацію про поточний стан автомату на надає її
користувачу. Модифікований таким чином автомат буде використаний для
моделювання економічної взаємодії робітників, підприємств та держави. Також,
буде створена система візуалізації клітинних автоматів з підтримкою описаних
вище модифікацій.
* Модифікація клітинних автоматів
** Огляд клітинних автоматів
Вперше клітинні автомати були запропоновані у 1940-50-х роках в роботах фон
Неймана та Улама[1]. Проте наступні 30 років такий тип автоматів не дуже
цікавив дослідників. У 1970-х Конвей запропонував так звану Гру Життя (Game of
Life) - двовимірний клітинний автомат, що описувався простим набором правил,
проте генерував напрочуд цікаво поведінку. В 1980-х глибоким дослідженням
одновимірних клітинних автоматів займався Стівен Вольфрам, зокрема він
запропонував їх класифікацію.

Клітинні автомати - особливий клас дискретних динамічних систем, дискретними в
яких є час, простір та множина станів. Зазвичай клітинний автомат
представляється як об'єднання однакових комірок (клітин), з'єднаних між
собою. Разом клітини утворюють так звану клітинну решітку (форма якої може
бути різноманітною). Клітина виступає скінченним автоматом, стан якого на
кроці /t+1/ визначається станом системи (а саме сусідів та самої клітини) на
попередньому кроці /t/ та набором локальних правил взаємодії сусідніх
клітин. Рідше під час визначення стану використовуються глобальні правила -
такі, що визначають вплив певної загальної змінної на всі клітини автомату.[2]
Саме розширення такими глобальними правилами буде досліджено у даній роботі.

На кожному кроці кожна клітина приймає один із станів з наявної скінченної
множини станів /S/, котре може розглядатись як /k/-вимірний алфавіт /S/ = {0,
1, ..., k-1}.

Якщо кожна клітина має /2r/ сусідів, локальне правило переходу виглядає
наступним чином /ϕ : S^{2r+1} → S/. Правило може бути детермінованим або
стохастичним.

Для визначення сусідів конкретної клітини у двовимірному автоматі існує
декілька підходів, найпопулярніші з яких "сусідство" фон Неймана та
"сусідство" Мура[3]. Перший розглядає лише чотири клітини, котрі безпосередньо
торкаються поточної клітини (згори, знизу, зліва та справа). А другий підхід
додає до цих чотирьох ще чотири клітини, що знаходяться на діагоналях відносно
поточної клітини. Надалі буде розглядатись підхід Мура, тому правило переходу
можна записати наступним чином /a_{i,j}^{(t+1)} = ϕ(a_{i,j}^{(t)},
a_{i,j+1}^{(t)}, a_{i+1,j}^{(t)}, a_{i+1,j+1}^{(t)}, a_{i,j-1}^{(t)},
a_{i-1,j}^{(t)}, a_{i-1,j-1}^{(t)}, a_{i-1,j+1}^{(t)},
a_{i+1,j-11}^{(t)})/.

Так як автомат представляє собою обмежену сітку, постає проблема визначення
сусідів клітин, котрі знаходяться на межах цієї сітки. Одним з
найпопулярніших шляхів розв'язання проблеми є використання тороїдальної
структури сітки - якщо клітина немає сусіда згори, цим сусідом виступає
клітина на відповідній позиції знизу сітки, аналогічно відбувається "перехід"
для інших клітин на межах.

Ітеративний процес роботи автомату полягає у тому, що на кожному кроці
наведена вище функція застосовується до кожної клітини водночас. Тобто, кожна
клітина оброблюється паралельно та незалежно, що робить клітинні автомати
гарним інструментом моделювання процесів зі схожою паралельною структурою,
наприклад, економічної взаємодії.

Зазвичай клітинні автомати у пам'яті комп'ютера представляються як масиви
комірок, де кожна комірка відповідає певній клітині автомата. Водночас
більшість автоматів описується в термінах певної підмножини "живих" станів та
визначення сусідів клітин ("мертві" клітини можуть бути вираховані
користуючись цією інформацією). Тому такий автомат можливо представити просто
як множину "живих" клітин.[4] Саме такий варіант представлення (дещо
модифікований для конкретних задач) використовувався у роботі.
** Розширення керуючим інформаційним каналом
** Розширення вихідним інформаційним каналом
** Використання модифікованого автомату для розпізнавання необмеженої граматики
* Модель економічних відносин
** Опис моделі
** Загальна структура клітинного автомату
** Використання керуючого та вихідного каналів
* Візуалізація клітинних автоматів
** React та ідея virtual DOM
React[8] - бібліотека від Facebook, створена для побудови компонованих
графічних HTML-інтерфейсів. На відміну від багатьох інших подібних рішень,
дана бібліотека цілковито відмовилась від звичних шаблонів (HTML документів
"покращених" додатковими директивами, котрі динамічно замінюються на
необхідний вміст) і натомість пропонує використовувати компоненти - фактично,
JavaScript функції, що генерують HTML-розмітку, та дотримуються певних
вимог. Кожний компонент приймає як параметри два елементи - =props= (незмінні
дані) та =state= (змінні дані).

Ключовою особливістю React є те, що бібліотека автоматично підтримує
відображення у актуальному стані - компонент перемальовується у випадку зміни
даних, що використовуються ним. На перший погляд це здається надто повільним,
проте розробники використали цікавий підхід, котрий можна назвати virtual
DOM. Під час першої ініціалізації компоненту викликається метод =render=,
котрий генерує легковісне представлення відображення, з якого створюється
рядок з HTML-розміткою та додається у тіло документу. Надалі виклики методу
=render= призводять до повторної генерації проміжного представлення, котре
порівнюється з попереднім варіантом, з порівняння знаходиться мінімальний
набір змін, котрі необхідну виконати для перетворення попереднього
відображення у поточний варіант. Перетворюються у розмітку та застосовуються
вже ці, переважно невеликі, зміни. Можна сказати, що компонент у React - це
простий скінченний автомат, котрий генерує різне відображення в залежності від
поточного стану (значення даних, що використовуються компонентом).

Обробники подій додаються до компонентів просто як HTML-властивість певного
DOM-елементу, ключем якої є ім'я події у camelCase, а значенням - функція, що
оброблюватиме подію. У React імплементована своя система обробки подій, котра
намагається забезпечувати сумісність зі специфікацією W3C в незалежності від
броузеру, що використовується. Додатково для всіх обробників значення
JS-контексту автоматично встановлюється у поточний компонент. Також,
використовується делегація подій - обробники приєднуються не безпосередньо до
відповідних DOM-елементів, а створюється один загальний обробник, котрий
приєднується до кореневого елементу і викликає необхідний користувацький
обробник в залежності від події, що відбулась.

Компоненти бібліотеки є модульними - кожен з них може бути частиною іншого
компоненту та містити компоненти у собі. Якщо компонент містить інші
компоненти, він є їх власником та відповідальний за заповнення =props= всіх
компонентів, що "належать" йому. Більш формально, компонент є власником всіх
компонентів, що створюються у його =render=-методі.

Кожен компонент обов'язково має визначити метод =render= - генерує опис одного
DOM-елементу, котрий мусить бути відображеним на сторінці. Даний метод має
бути чистим (як у понятті чиста функція) - якщо на вхід подаються однакові
параметри, результат має також бути однаковим. Водночас, React визначає доволі
детальний життєвий цикл компонентів, для модифікації обробки кожного з його
етапів достатньо додатково визначити відповідний метод під час опису
компоненту. Передбачені наступні фази:

- =getInitialState= :: викликається один раз перед додаванням компоненту у
     DOM; значення, що повертається, використовується як початкове для =state=
- =getDefaultProps= :: викликається один раз перед додаванням компоненту у
     DOM;значення, що повертається, використовується як початкове для =props=
- =componentWillMount= :: викликається один раз перед додаванням компоненту у
     DOM
- =componentDidMount= :: викликається одразу після додавання компоненту у DOM
- =componentWillReceiveProps= :: викликається під час отримання компонентом
     нових =props=, але перед генерацією нового відображення
- =shouldComponentUpdate= :: викликається перед генерацією відображення після
     отримання нових =props= або =state=; якщо метод повертає =false=,
     генерація нового відображення не буде проводитись
- =componentWillUpdate= :: викликається перед генерацією нового відображення
     після отримання нових =props= або =state=
- =componentDidUpdate= :: викликається одразу після генерації нового
     відображення після отримання нових =props= або =state=
- =componentWillUnmount= :: викликається перед тим, як компонент буде
     видалений з DOM

Для опису HTML-елементів всередині компонентів пропонується набір функцій з
простору імен =React.DOM=, кожна з яких відповідає певному HTML-тегу:
наприклад, посилання створюється наступним чином:

#+BEGIN_SRC javascript
var link = React.DOM.a({href: 'http://google.com'}, 'Google');
#+END_SRC

Також розробники створили простий трансформатор синтаксису JavaScript-файлів
JSX, котрий дозволяє створювати HTML-елементи у JavaScript-коді майже так
само, як у звичайних HTML-файлах. Наприклад, попередній приклад буде виглядати
так:

#+BEGIN_SRC javascript
/** @jsx React.DOM */

var link = <a href="http://google.com">Google</a>
#+END_SRC

Коментар на початку обов'язковий, він виконує функцію аналогічну
=pragma=-конструкціям у С++, вказуючи інтерпретатору виконати трансформацію
синтаксису перед інтерпретацією.

Для прив'язки створеного компонента до елемента на сторінці використовується
функція =React.renderComponent=, першим параметром якої є компонент, а
другим - DOM-елемент, до якого компонент має бути прив'язаним. Наведемо
приклад створення та прив'язки композитного компоненту - списку коментарів
від різних авторів[9]:

#+BEGIN_SRC javascript
/** @jsx React.DOM */

var data = [
  {author: "Pete Hunt", text: "This is one comment"},
  {author: "Jordan Walke", text: "This is *another* comment"}
];

var Comment = React.createClass({
  render: function() {
    return (
      <div className="comment">
        <h2 className="commentAuthor">
          {this.props.author}
        </h2>
        {this.props.children}
      </div>
    );
  }
});

var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function (comment) {
      return <Comment author={comment.author}>{comment.text}</Comment>;
    });
    return (
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});

var CommentBox = React.createClass({
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.props.data} />
      </div>
    );
  }
});

React.renderComponent(
  <CommentBox data={data} />,
  document.getElementById('content')
);
#+END_SRC

Компонент =CommentBox= є кореневим компонентом, він приймає на вхід список
коментарів та передає їх компоненту =CommentList=, котрий перетворює кожний
елемент списку у компонент =Comment= та відображає їх одним списком.

** ClojureScript та Om
Для реалізації застосування використовувалась мова програмування
ClojureScript. Вона є варіантом мови Clojure, котрий запускається не на JVM, а
компілюється у JavaScript. Хоча й ClojureScript не має всіх можливостей мови
Clojure (зокрема, багатопоточності), але підтримує базову семантику даної
мови, зокрема незмінні структури даних, "ліниві" послідовності, функції вищого
порядку, простори імен та навіть макроси. Основна відмінність між Clojure та
ClojureScript - якщо перша мова працює спільно з Java та має можливості
інтероперабельності з саме цією мовою, то друге вже використовує JavaScript у
ролі "батьківського" середовища та інтероперує з ним.

ClojureScript генерує немініфікований та необфускований JavaScript код, котрий
надалі передається на вхід Google Closure Compiler[5], котрий і оптимізує
отриманий код. Разом з компілятором до складу Google Closure входить набір
низькорівневих бібліотек для більшості буденних задач, що виникають під час
розробки JavaScript застосувань - наприклад, надсилання запитів до
сервера. ClojureScript надає до них повний доступ без необхідності їх
додаткового завантаження та додавання на сторінку.

Цікавою особливістю є те, що і компілятор ClojureScript, і компілятор Google
Closure запускається на JVM - перший компілятор написаний на Clojure, а другий
на Java. Загалом процес перетворення ClojureScript у готовий до використання
JavaScript код відбувається наступним чином[6]:

[[./cljs_compilation.png]]

Генерація HTML-відображення у застосуванні здійснюється за допомогою
бібліотеки Om[7]. Вона є обгорткою над розглянутою раніше JS-бібліотекою
React, а також додає власну модель збереження стану застосування.

Om, як і React, пропонує використовувати незалежні, але зв'язані один з одним,
компоненти, проте на відміну від React, всі дані, що передаються між
компонентами є незмінними. Завдяки цьому та особливостям реалізації
незмінності у Clojure/ClojureScript вдається досягти ще більшої швидкості
роботи, адже для визначення того, чи потрібно перемальовувати компонент
достатньо порівняти указники параметрів, а не їх вміст.

Всі дані, необхідні для генерації відображення, зберігаються у одному
кореневому контейнері, котрий змінюється за допомогою механізму
транзакцій. Зазвичай контейнером виступає звичайний асоціативний масив, що має
деревоподібну структуру (тобто, має багато вкладених асоціативних масивів),
кожна "гілка" цього масиву використовується одним з (або декількома)
компонентами, що входять до складу застосування.

Всередину компоненту передається не сам контейнер з даними, а так званий
курсор, що описує певний шлях всередину контейнеру (на концептуальному рівні
курсор схожий на таке поняття зі сфери структур даних як zipper). Фактично,
курсор обмежує область видимості даних для компонента лише необхідними йому
даними, водночас зберігає можливість оновлювати ці дані з компоненту, не
знаючи про загальну структуру контейнера з даними.

Для кожного з етапів життєвого циклу компоненту React передбачений бібліотекою
передбачений свій протокол - для того, щоб визначити особливу поведінку під
час конкретного етапу, достатньо реалізувати відповідний протокол. Кожний
Om-компонент має визначити щонайменше протокол, котрий описує render-фазу
(безпосередню генерацію HTML, протокол IRender або IRenderState). Під час
створення екземпляру компонента йому обов'язково передається курсор на певну
частину загального контейнера з даними. Дані з курсору доступні напряму під
час фази render, проте під час інших фаз до них можна звертатись лише як до
атому (один з базових елементів Clojure/ClojureScript) - попередньо потрібно
"розіменувати" (dereference) посилання, котрим, по суті, є курсор.

Для генерації HTML можна використовувати стандартне API React'у =React.DOM=
(що і було обрано для даної роботи), також існує декілька Om-специфічних
додаткових бібліотек.

Прив'язка компоненту до DOM-елементу здійснюється за допомогою функції
=om/root=, котра дещо відрізняється від варіанту React. Першим аргументом так
само приймається компонент, а от другим вже виступає контейнер з даними. Також
приймається третій параметр - асоціативний масив з додатковою конфігурацією,
зокрема DOM-елементом, до якого слід прив'язати компонент.

Наведемо Om-компоненти, що відповідають вищеописаному прикладу для React:

#+BEGIN_SRC clojure
(ns example
  (:require [om.core :as om :include-macros true]
            [om.dom :as dom :include-macros true]))

(def data (atom [{:author "Pete Hunt" :text "This is one comment"}
                 {:author "Jordan Walke" :text "This is *another* comment"}]))

(defn comment [comment owner]
  (reify
    om/IRender
    (render [this]
      (dom/div #js {:className "comment"}
        (dom/h2 #js {:className "commentAuthor"} (:author comment))
        (:text comment)))))

(defn comment-list [comments owner]
  (reify
    om/IRender
    (render [this]
      (dom/div #js {:className "commentList"}
        (om/build-all comment comments)))))

(defn comment-box [data owner]
  (reify
    om/IRender
    (dom/div #js {:className "commentBox"}
      (dom/h1 nil "Comments")
      (om/build comment-list data))))

(om/root comment-box data
  {:target (. js/document (getElementById "content"))})
#+END_SRC

Цікавою відмінністю від Om від React'у є обробники подій. Якщо в останньому
зазвичай обробник подій несе у собі безпосередню логіку, котра має виконатись
у відповідь на події, в Om часто використовують інший підхід - обробник лише
переправляє інформацію про подію в канал даних, створений за допомогою
реалізації CSP для Clojure/ClojureScript. Обробка нових повідомлень у каналі
зазвичай відбувається у "батьківському" компоненті, в якому і створюються всі
необхідні канали: їх створення відбувається під час фази =getInitialState=, а
додавання обробників повідомлень з каналів - під час
=componentWillMount=. Таким чином можливе значно спростити код
компонентів-дітей (бо вся їх логіка це просто пересилання повідомлень), і
зосередити обробку всіх подій в одному місці. Загалом, даний підхід досить
схожий на PubSub, проте й має свої особливості. Розглянемо його детальніше в
наступному розділі.
** Communicating Sequential Processes та core.async
Communicating Sequential Processes - формальна мова опису схем взаємодії у
паралельних системах, котра є представником так званих алгебр процесів
(process calculi) і базується на передачі повідомлень каналами
(channel). Вперше CSP було описано у 1978 році в роботі C. A. R. Hoare.[10]

Найяскравішими представниками підходу є мови програмування occam, Limbo, Go та
бібліотека =core.async=. Донедавна підхід рідко використовувався у практичних
задачах, але відносно часто залучався для специфікації та верифікації
паралельних аспектів складних систем, наприклад мікропроцесора INMOS T9000
Transputer. Цікавим використанням було моделювання системи управління
відмовами створеної для використання на Міжнародній Космічній станції, котре
проводилось Бременським інститутом безпечних систем та Daimler-Benz
Aerospace - за допомогою CSP дослідники довели, що їх система не містить
deadlock'ів та livelock'ів. При цьому під час процесу моделювання та аналізу
було виявлено певну кількість помилок, котрі не могли бути знайдені звичайними
тестами. Схожим чином Praxis High Integrity Systems залучило CSP для
верифікації своєї системи Certification Authority для смарт-карт - компанія
стверджує, що завдяки цьому їх рішення має набагато менший рівень відмов, ніж
пропозиції конкурентів.

В останні роки CSP починають все частіше використовувати і у повсякденних
прикладних задачах (як от, побудова асинхронних веб-застосувань, графічних
інтерфейсів), насамперед через поширення мови програмування Go, модель
паралельності якої повністю будується на даному підході.

CSP дозволяє описувати системи як набір незалежних компонент-процесів, котрі
взаємодіють один з одним лише за допомогою передачі повідомлень. Взаємодія між
процесами один з одним та з середовищем описується за допомогою спеціальних
операторів алгебри процесів. Поєднуючи декілька основних примітивів різним
чином, можливо легко описувати навіть доволі складні системи.

Існує два основних класи примітивів:

- події :: акт спілкування або взаємодії. Вважається, що вони є неподільними
           та миттєвими.
- примітивні процеси :: процеси, що описують базову поведінку, наприклад, STOP
     (процес, що нічого не передає - deadlock) та SKIP (описує успішне
     завершення роботи)

Найважливішими операторами є:

- префікс :: поєднує подію і процес, породжуючи новий процес. Наприклад, a -> P
             описує процес, що чекає на подію а, а після цього поводиться як
             процес P
- детермінований вибір :: описує процес, робота якого розвивається за двома
     різними шляхами в залежності від того, яка події надійде з
     оточення. Наприклад, якщо відбувається подія a буде виконуватись процес
     P, а якщо подія b - то процес Q
- недетермінований вибір :: схожий на попередній, але розвиток процесу не
     залежить від оточення, а чекає на те, поки відбудуться обидві події, а
     потім "самостійно" (в залежності від внутрішнього стану системи)
     визначає, яку гілку виконання обрати
- перетинання (interleave) :: описує процес, що поєднує в собі незалежну
     одночасну роботу двох інших процесів
- паралельний інтерфейс (interface parallel) :: процес, що поєднує в собі
     роботу одночасну роботу двох інших процесів, при цьому вони мусять
     синхронізуватись один з одним - вказані в операторі події можуть бути
     оброблені, лише коли обидва процеси здатні їх обробити
- сховування (hiding) :: описує процес, котрий не оброблює вказані події, які
     оброблюються базовим процесом

Хоча дана теорія доволі схожа з моделлю акторів, існує декілька
фундаментальних відмінностей у примітивах, що використовуються у даних
підходах:

- процеси в CSP анонімні, а актори мають "ідентичність";
- в CSP передача повідомлень вимагає явної "зустрічі" між відсилачем та
  отримувачем повідомлення - повідомлення не може бути надіслане допоки нема
  отримувача, здатного його прийняти. Натомість, в моделі акторів надсилання
  повідомлень є повністю асинхронним;
- CSP використовує явні канали для передачі повідомлень, а модель акторів
  передає їх іменованим отримувачам (акторам).

Як вказувалось раніше, в моєму застосуванні використовується реалізація CSP
для мови програмування Clojure/ClojureScript, а саме бібліотека
=core.async=. Вона надає можливість асинхронного програмування за допомогою
каналів. Основними задачами бібліотеки є:

- надати інструменти для незалежних потоків дій, що взаємодіють за допомогою
  подібних до черг каналів;
- підтримка "справжніх" потоків та сумісного використання потоків з пулу;
- базуватись на CSP, водночас розвиваючи її.[11]

Як було сказано раніше про CSP, головною ознакою каналів є те, що вони
блокуючі. Водночас, бібліотека надає можливість створювати буферизовані
канали, здатні приймати задану кількість повідомлень без необхідності їх
моментального отримування.

Використання бібліотеки у Clojure та ClojureScript дещо відрізняється, так як
моє застосування написане на ClojureScript, надалі зосередимось на розгляді
API саме цієї версії.

Використання бібліотеки починається з імпортування визначених у ній функцій:

#+BEGIN_SRC clojure
(require-macros '[cljs.core.async.macros :refer :all])
(require '[cljs.core.async :refer :all])
#+END_SRC

Для створення каналу використовується наступна функція:

#+BEGIN_SRC clojure
(chan)
#+END_SRC

Створений канал можливо "закрити" - він перестає приймати в себе нові
повідомлення, але ті, що вже в ньому присутні, все що доступні для
читання. Коли всі повідомлення з каналу вичерпані, він повертає nil.

#+BEGIN_SRC clojure
(close! (chan))
#+END_SRC

Так як JavaScript однопоточний, бібліотека використовує аналог легковісних
потоків для створення уявлення багатопоточної обробки повідомлень. Для цього
операції треба "огортати" код у спеціальний макрос =go=, котрий передає дії на
асинхронне виконання, повертає інший канал, в якому з'явиться результат
операцій і дозволяє програмі продовжувати своє виконання. Базовими операціями
над каналом є запис та читання повідомлень:

#+BEGIN_SRC clojure
(let [c (chan 3)]
  (go (>! c "hello")
      (<! c)))
#+END_SRC

Якщо потрібно чекати на появу повідомлення в одному з декількох каналів, можна
використовувати операцію alts!:

#+BEGIN_SRC clojure
(let [c1 (chan)
      c2 (chan)]
  (go (while true
        (let [[v ch] (alts! [c1 c2])]
          (println "Read" v "from" ch))))
  (go (>! c1 "hi"))
  (go (>! c2 "there")))
#+END_SRC
** Огляд виконаної реалізації
Застосування було виконано у формі так званого single-page application, при
чому серверна частина у нього відсутня, всі обрахунки відбуваються на
клієнтській стороні.
* Висновки
* Список літератури
1. Клеточные автоматы. Реализация и эксперименты - Лев Наумов, Анатолий Шалыто
2. Modelling the Spatial Dimension of Economic Systems with Cellular
   Automata - Max Keilbach
3. https://en.wikipedia.org/wiki/Cellular_automaton
4. Clojure Programming - Chas Emerick, Brian Carper, Christophe Gran
5. https://developers.google.com/closure/
6. ClojureScript Up and Running - Stuart Sierra, Luke VanderHart
7. https://github.com/swannodette/om
8. http://facebook.github.io/react/blog/2013/06/05/why-react.html
9. http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html
10. https://en.wikipedia.org/wiki/Communicating_sequential_processes
11. http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html
